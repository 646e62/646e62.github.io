[
  {
    "objectID": "notebooks/high_treason_expert_system.html",
    "href": "notebooks/high_treason_expert_system.html",
    "title": "informatics.legal",
    "section": "",
    "text": "HIGH_TREASON_RULES = {\n    \"sovereign\": [(\"Did the defendant kill the sovereign?\",\n                   [\"kill\"]),\n                  (\"Did the defendant attempt to kill the sovereign?\",\n                   [\"kill\", \"attempt\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause death?\",\n                   [\"bodily harm\", \"tending to death\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause destruction?\",\n                   [\"bodily harm\", \"tending to destruction\"]),\n                  (\"Did the defendant maim the sovereign?\",\n                   [\"maim\"]),\n                  (\"Did the defendant wound the sovereign?\",\n                   [\"wound\"]),\n                  (\"Did the defendant imprison the sovereign?\",\n                   [\"imprison\"]),\n                  (\"Did the defendant restrain the sovereign?\",\n                   [\"restrain\"])],\n    \"canada\": [(\"Did the defendant levy war against Canada?\",\n                [\"levy war\"]),\n               (\"Did the defendant prepare to levy war against Canada?\",\n                [\"prepare\", \"levy war\"]),\n               (\"Did the defendant assist an enemy at war with Canada?\",\n                [\"assist warring enemy\"]),\n               (\"Did the defendant assist an armed force hostily engaged with Canadian Forces?\",\n                [\"assist hostile force\"])]}\n\n\ndef get_sovereign_actions() -&gt; list:\n    \"\"\"\n    Ask the user questions related to actions against the sovereign.\n    \"\"\"\n\n    actions = []\n    for question in HIGH_TREASON_RULES[\"sovereign\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"sovereign\", question[1]))\n    \n    return actions\n\n\ndef get_canada_actions() -&gt; list:\n    \"\"\"\n    Ask the user questions related to actions against Canada.\n    \"\"\"\n\n    actions = []\n    for question in HIGH_TREASON_RULES[\"canada\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"canada\", question[1]))\n\n    return actions\n\ndef high_treason_facts(victim_category) -&gt; list:\n    \"\"\"\n    Asks the user questions to determine if the facts of the case make out the offence of high treason.\n    \"\"\"\n    actions = []\n\n    if victim_category.lower() == 'sovereign':\n        actions = get_sovereign_actions()\n    elif victim_category.lower() == 'canada':\n        actions = get_canada_actions()\n\n    return actions\n\n\nclass Facts:\n    \"\"\"\n    A basic class capable of handling the minimum facts required for a high \n    treason offence.\n\n    Attributes:\n        victim_category (str): The name of the victim of the offence.\n        offence_date (str): The date of the offence.\n        jurisdiction (str): The jurisdiction in which the offence took place.\n        actions (list): A list of actions that the defendant took against the \n            victim.\n        role (list): A list of roles that the defendant played in the offence.\n\n    A Facts object should account for one offence and offender. Any potential\n    path to a conviction should be represented by a distinct Facts object. \n    Multiple offences or offenders should be represented by multiple Facts \n    objects.\n    \"\"\"\n\n    def __init__(self, \n                 victim_category: str, \n                 offence_date: str, \n                 jurisdiction: str, \n                 actions: list = None, \n                 role: list = None\n                ):\n        self.victim_category = victim_category\n        self.offence_date = offence_date\n        self.jurisdiction = jurisdiction\n        self.actions = actions if actions is not None else []\n        self.role = role if role is not None else []\n\n\n'''\nRules determining whether a factual matrix corresponds to offence elements.\n'''\n\ndef high_treason_rules(facts):\n    \"\"\"\n    Checks if the facts of the case make out the offence of high treason.\n    \"\"\"\n    matches = []  # create an empty list to hold matches\n\n    # Check if any of the actions in the facts are in the list of high treason actions\n    for action in facts.actions:\n        complainant_key = action[0] \n        action_value = action[1]\n\n        if complainant_key in HIGH_TREASON_RULES: # Checks to see if the complainant category lines up with one of the two in HIGH_TREASON RULES\n            tuple_list = HIGH_TREASON_RULES[complainant_key]\n            for item in tuple_list:\n                if action_value == item[1]:\n                    matches.append(item)  # append the matching item to the list\n    return matches  # return the list of matches\n\n\nclass Complainant:\n    \"\"\"\n    Creates a complainant instance. \n    \"\"\"\n    def __init__(self, name=None, age=None, category=None):\n        self.name = name\n        self.age = age\n        self.category = category\n\nclass Defendant:\n    \"\"\"\n    Creates a defendant instance. Necessary to the extent that some offences \n    only apply to defendants with certain characteristics, and to the extent\n    that some offences will involve multiple defendants who need to be kept\n    distinct from one another.\n    \"\"\"\n    def __init__(self, name=None, age=None, liability=None, criminal_record=None):\n        self.name = name\n        self.age = age\n        self.liability = liability\n        self.criminal_record = criminal_record\n\n\n\"\"\"\nFunctions used to process input strings and correct them to a standard format.\n\"\"\"\n\n# High treason\n\ndef standardize_sovereign_names(name):\n    \"\"\"\n    This function takes a name and standardizes it to 'Sovereign' if it matches any of the known aliases.\n    \"\"\"\n    known_aliases = ('queen', 'king', 'queen elizabeth', 'king charles')\n    if name.lower() in known_aliases:\n        return 'sovereign'\n    else:\n        return name\n\ndef standardize_canada_names(name):\n    \"\"\"\n    This function takes a name and standardizes it to 'Canada' if it matches any of the known aliases.\n    \"\"\"\n    known_aliases = ('nation of canada', 'canadian people', 'canadian military')\n    if name.lower() in known_aliases:\n        return 'canada'\n    else:\n        return name\n\n# Treason\n\ndef treason_location_type(input_string: str) -&gt; str:\n    \"\"\"\n    This function helps determine whether a string entity is a province or a \n    federally-regulated territory for the purpose of determining whether a \n    defendant has committed treason.\n    \"\"\"\n    input_string = input_string.replace('.', '')  # Remove periods from input\n\n    # Dictionary mapping province names, abbreviations and territory names, abbreviations to their corresponding types\n    locations = {\n        \"alberta\": \"province\",\n        \"ab\": \"province\",\n        \"alta\": \"province\",\n        \"british columbia\": \"province\",\n        \"bc\": \"province\",\n        \"manitoba\": \"province\",\n        \"mb\": \"province\",\n        \"man\": \"province\",\n        \"new brunswick\": \"province\",\n        \"nb\": \"province\",\n        \"newfoundland and labrador\": \"province\",\n        \"nl\": \"province\",\n        \"nova scotia\": \"province\",\n        \"ns\": \"province\",\n        \"ontario\": \"province\",\n        \"on\": \"province\",\n        \"ont\": \"province\",\n        \"prince edward island\": \"province\",\n        \"pei\": \"province\",\n        \"quebec\": \"province\",\n        \"qc\": \"province\",\n        \"que\": \"province\",\n        \"saskatchewan\": \"province\",\n        \"sk\": \"province\",\n        \"sask\": \"province\",\n        \"northwest territories\": \"canada\",\n        \"nt\": \"canada\",\n        \"nwt\": \"canada\",\n        \"nunavut\": \"canada\",\n        \"nu\": \"canada\",\n        \"nvt\": \"canada\",\n        \"yukon\": \"canada\",\n        \"yt\": \"canada\"\n    }\n\n    # Return the corresponding value if the input string is in the dictionary, else return \"Unknown\"\n    return locations.get(input_string.lower(), \"Unknown\")\n\n\ndef create_facts():\n    \"\"\"\n    Creates a Facts object that can then be read using the rule base.\n    \"\"\"\n\n    print(\"Please enter the facts of the case:\")\n\n    victim_category = input(\"Who is the victim? \")\n    victim_category = standardize_sovereign_names(victim_category)\n    victim_category = standardize_canada_names(victim_category)\n    complainant = Complainant(victim_category)\n\n    offence_date = input(\"Date of the offence (YYYY-MM-DD): \")\n    jurisdiction = input(\"Jurisdiction: \")\n\n    actions = high_treason_facts(victim_category)\n\n    return Facts(complainant.name, offence_date, jurisdiction, actions)\n\ndef verify_high_treason(matches):\n    if matches:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)\n    else:\n        print(\"No offence detected.\")\n\ndef high_treason_system():\n\n    facts = create_facts()\n    matches = high_treason_rules(facts)\n    \n    verify_high_treason(matches)\n    \n    return matches\n\n\n# matches = high_treason_system()\n\nPlease enter the facts of the case:\nHigh treason committed. Matches:\n('Did the defendant assist an enemy at war with Canada?', ['assist warring enemy'])\n\n\nWho is the victim?  canada\nDate of the offence (YYYY-MM-DD):  2022-10-10\nJurisdiction:  SK\nDid the defendant levy war against Canada? (yes/no):  no\nDid the defendant prepare to levy war against Canada? (yes/no):  no\nDid the defendant assist an enemy at war with Canada? (yes/no):  yes\nDid the defendant assist an armed force hostily engaged with Canadian Forces? (yes/no):  no\n\n\n\nif matches:\n    print(\"High treason committed. Matches:\")\n    for match in matches:\n        print(match)\nelse:\n    print(\"No offence detected.\")\n\nHigh treason committed. Matches:\n('Did the defendant assist an enemy at war with Canada?', ['assist warring enemy'])"
  },
  {
    "objectID": "notebooks/high_treason_expert_system.html#rules_constants.py",
    "href": "notebooks/high_treason_expert_system.html#rules_constants.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "",
    "text": "This file contains the questions that, once answered, can generate the factual matrix needed to determine whether the defendant committed high treason. The conditional flow is clumsy, but the questions employed that way for now may be useful for GPT-3.5-style prompts at a later point.\n\nHIGH_TREASON_RULES = {\n    \"sovereign\": [(\"Did the defendant kill the sovereign?\",\n                   [\"kill\"]),\n                  (\"Did the defendant attempt to kill the sovereign?\",\n                   [\"kill\", \"attempt\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause death?\",\n                   [\"bodily harm\", \"tending to death\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause destruction?\",\n                   [\"bodily harm\", \"tending to destruction\"]),\n                  (\"Did the defendant maim the sovereign?\",\n                   [\"maim\"]),\n                  (\"Did the defendant wound the sovereign?\",\n                   [\"wound\"]),\n                  (\"Did the defendant imprison the sovereign?\",\n                   [\"imprison\"]),\n                  (\"Did the defendant restrain the sovereign?\",\n                   [\"restrain\"])],\n    \"canada\": [(\"Did the defendant levy war against Canada?\",\n                [\"levy war\"]),\n               (\"Did the defendant prepare to levy war against Canada?\",\n                [\"prepare\", \"levy war\"]),\n               (\"Did the defendant assist an enemy at war with Canada?\",\n                [\"assist warring enemy\"]),\n               (\"Did the defendant assist an armed force hostily engaged with Canadian Forces?\",\n                [\"assist hostile force\"])]}"
  },
  {
    "objectID": "notebooks/high_treason_expert_system.html#facts.py",
    "href": "notebooks/high_treason_expert_system.html#facts.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "facts.py",
    "text": "facts.py\n'''\nGenerates a factual matrix that can be used to determine whether the facts of\nthe case make out a particular offence.\n'''\nAt first glance there may be some advantage to having the get_actions() functions return True/False, rather than a list. After all, if any one condition is met, the defendant committed high treason. But this overlooks the fact that a defendant may have committed the same offence through different means. A person who levies war against Canada AND assists a separate armed force hostily engaged with Canadian Forces commits high treason twice. Similarly, a person may have caused the sovereign bodily harm that amounts to both maiming and bodily harm tending to cause death, and can be fairly charged and tried for both offences (albeit not convicted of both, per Stinchcombe.) A list allows the program to record multiple offence instances using fewer passes. Lists save time and ensure the program remains extensible.\n\ndef get_sovereign_actions() -&gt; list:\n    \"\"\"\n    Ask the user questions related to actions against the sovereign.\n    \"\"\"\n\n    actions = []\n    for question in HIGH_TREASON_RULES[\"sovereign\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"sovereign\", question[1]))\n    \n    return actions\n\n\ndef get_canada_actions() -&gt; list:\n    \"\"\"\n    Ask the user questions related to actions against Canada.\n    \"\"\"\n\n    actions = []\n    for question in HIGH_TREASON_RULES[\"canada\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"canada\", question[1]))\n\n    return actions\n\ndef high_treason_facts(victim_category) -&gt; list:\n    \"\"\"\n    Asks the user questions to determine if the facts of the case make out the offence of high treason.\n    \"\"\"\n    actions = []\n\n    if victim_category.lower() == 'sovereign':\n        actions = get_sovereign_actions()\n    elif victim_category.lower() == 'canada':\n        actions = get_canada_actions()\n\n    return actions"
  },
  {
    "objectID": "notebooks/high_treason_expert_system.html#models.py",
    "href": "notebooks/high_treason_expert_system.html#models.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "models.py",
    "text": "models.py\nOnce the program gathers this information, it needs a place to store it. The Facts class takes this job on. The version below contemplates a few variables that aren’t in use yet. Because this class is currently being used for just one offence, it only needs to be able to store the victim category and the defendant’s actions.\n\nclass Facts:\n    \"\"\"\n    A basic class capable of handling the minimum facts required for a high \n    treason offence.\n\n    Attributes:\n        victim_category (str): The name of the victim of the offence.\n        offence_date (str): The date of the offence.\n        jurisdiction (str): The jurisdiction in which the offence took place.\n        actions (list): A list of actions that the defendant took against the \n            victim.\n        role (list): A list of roles that the defendant played in the offence.\n\n    A Facts object should account for one offence and offender. Any potential\n    path to a conviction should be represented by a distinct Facts object. \n    Multiple offences or offenders should be represented by multiple Facts \n    objects.\n    \"\"\"\n\n    def __init__(self, \n                 victim_category: str, \n                 offence_date: str, \n                 jurisdiction: str, \n                 actions: list = None, \n                 role: list = None\n                ):\n        self.victim_category = victim_category\n        self.offence_date = offence_date\n        self.jurisdiction = jurisdiction\n        self.actions = actions if actions is not None else []\n        self.role = role if role is not None else []"
  },
  {
    "objectID": "notebooks/high_treason_expert_system.html#rules.py",
    "href": "notebooks/high_treason_expert_system.html#rules.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "rules.py",
    "text": "rules.py\nOnce the factual matrix is put together, the program calls a rules function on those facts. This function first checks to see if the complainant_key matches either of the complainant categories in HIGH_TREASON_RULES. If so, the program checks to see if any of the facts attached to that key match the offence facts in HIGH_TREASON_RULES. If so, the function appends them to a list and returns it. If not, the function returns an empty list for the main function to interpret as a null result.\n\n'''\nRules determining whether a factual matrix corresponds to offence elements.\n'''\n\ndef high_treason_rules(facts):\n    \"\"\"\n    Checks if the facts of the case make out the offence of high treason.\n    \"\"\"\n    matches = []  # create an empty list to hold matches\n\n    # Check if any of the actions in the facts are in the list of high treason actions\n    for action in facts.actions:\n        complainant_key = action[0] \n        action_value = action[1]\n\n        if complainant_key in HIGH_TREASON_RULES: # Checks to see if the complainant category lines up with one of the two in HIGH_TREASON RULES\n            tuple_list = HIGH_TREASON_RULES[complainant_key]\n            for item in tuple_list:\n                if action_value == item[1]:\n                    matches.append(item)  # append the matching item to the list\n    return matches  # return the list of matches"
  },
  {
    "objectID": "notebooks/high_treason_expert_system.html#dev_models.py",
    "href": "notebooks/high_treason_expert_system.html#dev_models.py",
    "title": "rules.py",
    "section": "dev_models.py",
    "text": "dev_models.py\nThese models weren’t used to develop the first few versions of the high treason system, but models like this will be needed to extend the system to other offences. It may be needed to extend the high treason system to account for elements like jurisdiction, punishment, procedure, etc.\n\nclass Complainant:\n    \"\"\"\n    Creates a complainant instance. \n    \"\"\"\n    def __init__(self, name=None, age=None, category=None):\n        self.name = name\n        self.age = age\n        self.category = category\n\nclass Defendant:\n    \"\"\"\n    Creates a defendant instance. Necessary to the extent that some offences \n    only apply to defendants with certain characteristics, and to the extent\n    that some offences will involve multiple defendants who need to be kept\n    distinct from one another.\n    \"\"\"\n    def __init__(self, name=None, age=None, liability=None, criminal_record=None):\n        self.name = name\n        self.age = age\n        self.liability = liability\n        self.criminal_record = criminal_record"
  },
  {
    "objectID": "notebooks/high_treason_expert_system.html#input_correction.py",
    "href": "notebooks/high_treason_expert_system.html#input_correction.py",
    "title": "rules.py",
    "section": "input_correction.py",
    "text": "input_correction.py\n\n\"\"\"\nFunctions used to process input strings and correct them to a standard format.\n\"\"\"\n\n# High treason\n\ndef standardize_sovereign_names(name):\n    \"\"\"\n    This function takes a name and standardizes it to 'Sovereign' if it matches any of the known aliases.\n    \"\"\"\n    known_aliases = ('queen', 'king', 'queen elizabeth', 'king charles')\n    if name.lower() in known_aliases:\n        return 'sovereign'\n    else:\n        return name\n\ndef standardize_canada_names(name):\n    \"\"\"\n    This function takes a name and standardizes it to 'Canada' if it matches any of the known aliases.\n    \"\"\"\n    known_aliases = ('nation of canada', 'canadian people', 'canadian military')\n    if name.lower() in known_aliases:\n        return 'canada'\n    else:\n        return name\n\n# Treason\n\ndef treason_location_type(input_string: str) -&gt; str:\n    \"\"\"\n    This function helps determine whether a string entity is a province or a \n    federally-regulated territory for the purpose of determining whether a \n    defendant has committed treason.\n    \"\"\"\n    input_string = input_string.replace('.', '')  # Remove periods from input\n\n    # Dictionary mapping province names, abbreviations and territory names, abbreviations to their corresponding types\n    locations = {\n        \"alberta\": \"province\",\n        \"ab\": \"province\",\n        \"alta\": \"province\",\n        \"british columbia\": \"province\",\n        \"bc\": \"province\",\n        \"manitoba\": \"province\",\n        \"mb\": \"province\",\n        \"man\": \"province\",\n        \"new brunswick\": \"province\",\n        \"nb\": \"province\",\n        \"newfoundland and labrador\": \"province\",\n        \"nl\": \"province\",\n        \"nova scotia\": \"province\",\n        \"ns\": \"province\",\n        \"ontario\": \"province\",\n        \"on\": \"province\",\n        \"ont\": \"province\",\n        \"prince edward island\": \"province\",\n        \"pei\": \"province\",\n        \"quebec\": \"province\",\n        \"qc\": \"province\",\n        \"que\": \"province\",\n        \"saskatchewan\": \"province\",\n        \"sk\": \"province\",\n        \"sask\": \"province\",\n        \"northwest territories\": \"canada\",\n        \"nt\": \"canada\",\n        \"nwt\": \"canada\",\n        \"nunavut\": \"canada\",\n        \"nu\": \"canada\",\n        \"nvt\": \"canada\",\n        \"yukon\": \"canada\",\n        \"yt\": \"canada\"\n    }\n\n    # Return the corresponding value if the input string is in the dictionary, else return \"Unknown\"\n    return locations.get(input_string.lower(), \"Unknown\")"
  },
  {
    "objectID": "notebooks/high_treason_expert_system.html#main.py",
    "href": "notebooks/high_treason_expert_system.html#main.py",
    "title": "rules.py",
    "section": "main.py",
    "text": "main.py\nThis function executes the program. It creates a Facts object by canvassing the minimum number of questions for the offence’s factual matrix. Once created, Facts is passed to the rules set which returns the final result.\nThe function is limited to high treason as defined in Criminal Code s 46, and thus has this rule set coded into tthe function. Future versions should modularize this rule set call.\n\ndef create_facts():\n    \"\"\"\n    Creates a Facts object that can then be read using the rule base.\n    \"\"\"\n\n    print(\"Please enter the facts of the case:\")\n\n    victim_category = input(\"Who is the victim? \")\n    victim_category = standardize_sovereign_names(victim_category)\n    victim_category = standardize_canada_names(victim_category)\n    complainant = Complainant(victim_category)\n\n    offence_date = input(\"Date of the offence (YYYY-MM-DD): \")\n    jurisdiction = input(\"Jurisdiction: \")\n\n    actions = high_treason_facts(victim_category)\n\n    return Facts(complainant.name, offence_date, jurisdiction, actions)\n\ndef verify_high_treason(matches):\n    if matches:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)\n    else:\n        print(\"No offence detected.\")\n\ndef high_treason_system():\n\n    facts = create_facts()\n    matches = high_treason_rules(facts)\n    \n    verify_high_treason(matches)\n    \n    return matches\n\n\nmatches = high_treason_system()\n\nPlease enter the facts of the case:\nHigh treason committed. Matches:\n('Did the defendant kill the sovereign?', ['kill'])\n('Did the defendant do bodily harm to the sovereign tending to cause death?', ['bodily harm', 'tending to death'])\n\n\nWho is the victim?  queen\nDate of the offence (YYYY-MM-DD):  1992\nJurisdiction:  canada\nDid the defendant kill the sovereign? (yes/no):  yes\nDid the defendant attempt to kill the sovereign? (yes/no):  no\nDid the defendant do bodily harm to the sovereign tending to cause death? (yes/no):  yes\nDid the defendant do bodily harm to the sovereign tending to cause destruction? (yes/no):  no\nDid the defendant maim the sovereign? (yes/no):  no\nDid the defendant wound the sovereign? (yes/no):  no\nDid the defendant imprison the sovereign? (yes/no):  no\nDid the defendant restrain the sovereign? (yes/no):  no\n\n\n\nif matches:\n    print(\"High treason committed. Matches:\")\n    for match in matches:\n        print(match)\nelse:\n    print(\"No offence detected.\")\n\nHigh treason committed. Matches:\n('Did the defendant kill the sovereign?', ['kill'])\n('Did the defendant do bodily harm to the sovereign tending to cause death?', ['bodily harm', 'tending to death'])"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m a staff lawyer with Legal Aid Saskatchewan practicing criminal defence out of Swift Current, Sask. All work and opinions expressed on this site are mine, and not necessarily (or impliedly) my employer’s."
  },
  {
    "objectID": "about.html#daniel-booy",
    "href": "about.html#daniel-booy",
    "title": "About",
    "section": "",
    "text": "I’m a staff lawyer with Legal Aid Saskatchewan practicing criminal defence out of Swift Current, Sask. All work and opinions expressed on this site are mine, and not necessarily (or impliedly) my employer’s."
  },
  {
    "objectID": "about.html#informatics.legal",
    "href": "about.html#informatics.legal",
    "title": "About",
    "section": "informatics.legal",
    "text": "informatics.legal\nI’ve built this website using Quarto on top of a GitHub Pages repo. Most code is done in and available as a Jupyter notebook, though I periodically use nvim and VS Code for their Copilot integrations.\nBlog posts may be periodically updated. As a GitHub Pages site, all previous blog post versions will be in the public repo attached to this website."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "TODO",
    "section": "",
    "text": "Items that need attention sooner than later.\n\n\n\nSinclair\nImmigration\nNolo contendere"
  },
  {
    "objectID": "posts/welcome/index.html#articles",
    "href": "posts/welcome/index.html#articles",
    "title": "TODO",
    "section": "",
    "text": "Sinclair\nImmigration\nNolo contendere"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "legal informatics",
    "section": "",
    "text": "BSES part 2: adding jurisdictional functionality\n\n\n\n\n\n\n\ncode\n\n\nbses\n\n\n\n\nThe BSES from the previous post covered most of high treason’s basics, but left out one question with some particular intra-statutory considerations — namely, jurisdiction. This next section adds this step and begins the process of incorporating other aspects of the Criminal Code into the program.\n\n\n\n\n\n\nJul 16, 2023\n\n\nDaniel Booy\n\n\n\n\n\n\n  \n\n\n\n\nBSES part 1: a basic statutory expert system\n\n\n\n\n\n\n\narticle\n\n\ncode\n\n\nanalysis\n\n\nbses\n\n\n\n\nDespite advances in generative AI, expert legal systems will continue to be necessary for legal tech and its applications. These systems can anticipate the hallucinations that generative AIs produce, guide them by prompting them along a control flow, and easily expose the logic underlying a legal AI’s decision. In this post I outline a high level basic statutory expert system (BSES) that answers a narrow, basic legal problem: whether a criminal defendant is guilty of high treason.\n\n\n\n\n\n\nJun 24, 2023\n\n\nDaniel Booy\n\n\n\n\n\n\n  \n\n\n\n\nTODO\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nJun 21, 2023\n\n\nDaniel Booy\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html",
    "href": "posts/basic-statutory-expert-system/index.html",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "",
    "text": "When reading up on legal tech’s intersections with AI and expert systems, researchers and writers frequently mention Robert Kowalski, Fariba Sadri, and Marek Sogot’s paper “The British Nationality Act as a Logic Program”1 as a black swan event in legal AI.2 Their paper outlined an expert legal system the authors designed and coded in Prolog. Reading through their report, it seemed that a Python program could produce similar results. This little project aims to do that, starting with a simple statutory example."
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#what-is-high-treason",
    "href": "posts/basic-statutory-expert-system/index.html#what-is-high-treason",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "What is high treason?",
    "text": "What is high treason?\nHigh treason is a criminal offence created by section 46(1) of the Canadian Criminal Code. When I wrote this post, the offence read as follows:\n\nHigh treason\n46 (1) Every one commits high treason who, in Canada,\n\nkills or attempts to kill Her Majesty, or does her any bodily harm tending to death or destruction, maims or wounds her, or imprisons or restrains her;\nlevies war against Canada or does any act preparatory thereto; or\nassists an enemy at war with Canada, or any armed forces against whom Canadian Forces are engaged in hostilities, whether or not a state of war exists between Canada and the country whose forces they are.\n\n\nAlthough treason has been a codified criminal offence since the Criminal Code, 1892, the distinction between treason and high treason is relatively recent. Before Parliament made significant amendments to the Criminal Code in the 1970s, treason and high treason were a single, albeit multi-faceted, codified offence.3 Historically, treason was one of three offences punishable by death,4 and remains one of the most severe offences in Canadian criminal law."
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#why-high-treason",
    "href": "posts/basic-statutory-expert-system/index.html#why-high-treason",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "Why high treason?",
    "text": "Why high treason?\nThere are several key advantages to working with an offence like high treason:\n\nMinimal statutory elements. Criminal Code s 46 contains a reasonably straightforward control flow with only a few possible outcomes each time the program asks the user to choose between options.\nFew conditional layers. High treason’s decision tree only contains a few conditional layers. At most, the user must make two decisions before reaching a result and can arrive at a result after as few as one decision. This conditional superficiality makes high treason easy to diagram and demonstrates some basic expert legal system fundamentals.\nUnderlitigated. Although all Canadian criminal offences begin as codified statutes, most accumulate greater complexity through litigation. Courts ask and answer what certain words mean in certain circumstances and often add dozens of conditions to one or more basic elemental steps. High treason is a relatively recently created and infrequently charged offence, with few (if any) reported cases turning up in any of the usual repositories. Infrequently charged offences are, by necessity, rarely judicially considered. This infrequency limits the degree to which the statute can be interpretively bifurcated and grow more complex.\nHighly integrated. Despite not appearing much in reported case decisions, high treason is a serious offence that attracts special consideration throughout the Criminal Code, such as punishment availability, mandatory trial procedures, evidentiary prerequisites, jurisdictional nuances, etc. These conditions require the basic expert system I develop here to remain extensible to these future inputs.\n\nHigh treason’s relative conceptual simplicity makes it an ideal offence to begin development. It is sufficiently complex to allow me to experiment with navigating control points while being straightforward enough to be captured by an automated expert system that answers a simple legal question."
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#the-projects-scope",
    "href": "posts/basic-statutory-expert-system/index.html#the-projects-scope",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "The project’s scope",
    "text": "The project’s scope\nThis project’s goal is to encapsulate high treason within an expert legal system fully. The project must account for the punishment, procedural, and jurisdictional components discussed above to be considered complete. But to start, I will represent high treason’s offence section at a high level. Once the basic control flow is outlined and codified, it can be made more extensible and further developed to incorporate these additional components."
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#high-treasons-elements",
    "href": "posts/basic-statutory-expert-system/index.html#high-treasons-elements",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "High treason’s elements",
    "text": "High treason’s elements\nCriminal Code s 46(1)’s wording describes the following offence elements:\n\nThe offence took place in Canada; AND\nWhere the complainant is the sovereign, the defendant:\nKilled the sovereign; OR\nAttempted to kill the sovereign; OR\nCaused the sovereign bodily harm tending to cause death; OR\nCaused the sovereign bodily harm tending to cause destruction; OR\nMaims the sovereign; OR\nWounds the sovereign; OR\nImprisons the sovereign; OR\nRestrains the sovereign; OR\nWhere the complainant is in Canada, the defendant:\nLevied war against Canada; OR\nPrepared to levy war against Canada; OR\nAssists an enemy at war with Canada; OR\nAssists an armed force engaged in hostilities with Canada.\n\nWhere none of these conditions obtain, the defendant did not commit high treason."
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#high-treasons-elements-as-a-flowchart",
    "href": "posts/basic-statutory-expert-system/index.html#high-treasons-elements-as-a-flowchart",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "High treason’s elements as a flowchart",
    "text": "High treason’s elements as a flowchart\nThese elements can also be represented in a decision tree as follows:\n\n\n\n\nflowchart TD\n    A[Did the defendant commit high treason?] --&gt; B1{The act took place in Canada}\n    B1 --&gt;|No| B2(Not guilty)\n    B1 --&gt;|Yes| C{Who is the complainant}\n    C --&gt; D[The sovereign]\n    C --&gt; E[Canada]\n    C --&gt; F[\"¬(The sovereign ∨ Canada)\"]\n    F --&gt; G(Not guilty)\n    E --&gt; H0{Did the defendant}\n    H0 --&gt; H1[Levy war against Canada]\n    H1 --&gt;|\"∨\"| H2[Prepare to levy war against Canada]\n    H2 --&gt;|\"∨\"| H3[Assist an enemy at war with Canada]\n    H3 --&gt;|\"∨\"| H4[Assist a hostile armed force engaged with Canada]\n    H4 --&gt;|Yes| I1(Guilty)\n    H4 --&gt;|No| I2(Not guilty)\n    D --&gt; J0{Did the defendant}\n    J0 --&gt; J1[Kill the sovereign]\n    J1 --&gt;|\"∨\"| J2[Attempt to kill the sovereign]\n    J2 --&gt;|\"∨\"| J3[Do bodily harm to the sovereign tending to cause death]\n    J3 --&gt;|\"∨\"| J4[Do bodily harm to the sovereign tending to cause destruction]\n    J4 --&gt;|\"∨\"| J5[Maim the sovereign]\n    J5 --&gt;|\"∨\"| J6[Wound the sovereign]\n    J6 --&gt;|\"∨\"| J7[Imprison the sovereign]\n    J7 --&gt;|\"∨\"| J8[Restrain the sovereign]\n    J8 --&gt;|Yes| K1(Guilty)\n    J8 --&gt;|No| K2(Not guilty)\n\n\n\n\n\nFigure 1: An ugly flowchart describing the basic expert system’s flow control\nViewed this way, it is apparent how this decision tree might be easily adapted into a Python script that can, at a high level with sufficient and reliable information, decide whether a defendant committed high treason."
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#rules_constants.py",
    "href": "posts/basic-statutory-expert-system/index.html#rules_constants.py",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "rules_constants.py",
    "text": "rules_constants.py\nCriminal offences occur when specific factual scenarios take place. This set of rules gives the user a rudimentary way of telling the program what facts exist, allowing it to record these facts when pertinent and return an opinion based on its analysis.\nCurrently, the program accomplishes this by first determining whether the victim falls into one of two classes covered by high treason. If so, the program asks several specific questions to determine whether there are enough additional facts to constitute the offence. If so, it records and returns the result. But if the complainant is not a member of the high treason complainant class or the defendant’s actions do not match the actus reus of any high treason variant, the function advises as much.\nI will outline this functionality below, but for now, the HIGH_TREASON_RULES constant contains all the information needed to get a minimally-viable high treason system going. It currently includes the complainant class as its key and a list of tuples as the key’s value. The tuples have a string at index 0 that prompts the user for a yes/no question and a list at index 1 containing factual information for a future function to read and relay.\n\nHIGH_TREASON_RULES = {\n    \"sovereign\": [(\"Did the defendant kill the sovereign?\",\n                   [\"kill\"]),\n                  (\"Did the defendant attempt to kill the sovereign?\",\n                   [\"kill\", \"attempt\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause death?\",\n                   [\"bodily harm,\" \"tending to death\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause destruction?\",\n                   [\"bodily harm,\" \"tending to destruction\"]),\n                  (\"Did the defendant maim the sovereign?\",\n                   [\"maim\"]),\n                  (\"Did the defendant wound the sovereign?\",\n                   [\"wound\"]),\n                  (\"Did the defendant imprison the sovereign?\",\n                   [\"imprison\"]),\n                  (\"Did the defendant restrain the sovereign?\",\n                   [\"restrain\"])],\n    \"canada\": [(\"Did the defendant levy war against Canada?\",\n                [\"levy war\"]),\n               (\"Did the defendant prepare to levy war against Canada?\",\n                [\"prepare\", \"levy war\"]),\n               (\"Did the defendant assist an enemy at war with Canada?\",\n                [\"assist warring enemy\"]),\n               (\"Did the defendant assist an armed force hostily engaged with Canadian Forces?\",\n                [\"assist hostile force\"])]}"
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#facts.py",
    "href": "posts/basic-statutory-expert-system/index.html#facts.py",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "facts.py",
    "text": "facts.py\nThis function generates a factual matrix that future processes will use to determine whether the case facts make out a particular offence.\nAt first, having the get_actions() functions return True/False rather than a list seems best. After all, if any one condition obtains, the defendant committed high treason. But this overlooks that a defendant may have committed the same offence through different means. A person who levies war against Canada AND assists a separate armed force hostile engaged with Canadian Forces commits high treason twice. Similarly, a person may have caused the sovereign bodily harm that amounts to both maiming and bodily harm tending to cause death and can be legally charged and tried for both offences (albeit not convicted of both, per Stinchcombe.) A list allows the program to record multiple offence instances using fewer passes. Lists save time and ensure the program remains extensible.\n\ndef get_sovereign_actions():\n    actions = []\n    for question in HIGH_TREASON_RULES[\"sovereign\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"sovereign\", question[1]))\n    return actions\n\ndef get_canada_actions():\n    actions = []\n    for question in HIGH_TREASON_RULES[\"Canada\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"Canada\", question[1]))\n    return actions\n\ndef high_treason_facts(victim_name):\n    actions = []\n\n    if victim_name.lower() == 'sovereign':\n        actions = get_sovereign_actions()\n    elif victim_name.lower() == 'canada':\n        actions = get_canada_actions()\n    return actions"
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#models.py",
    "href": "posts/basic-statutory-expert-system/index.html#models.py",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "models.py",
    "text": "models.py\nOnce the program gathers this information, it needs a place to store it. The Facts class takes this job on. The version below contemplates a few variables that still need to be used. Because the program currently uses this class for just one offence, it only needs to be able to store the victim category and the defendant’s actions.\nThe Facts class is a simple class capable of handling the minimum facts required for a high treason offence. It currently contains the following attributes:\n\nvictim_category (str): The name of the victim of the offence.\noffence_date (str): The date of the offence.\njurisdiction (str): The jurisdiction where the offence occurred.\nactions (list): A list of actions that the defendant took against the victim.\nrole (list): A list of roles that the defendant played in the offence.\n\nA Facts object should account for one offence and offender. A distinct Facts object should represent any potential path to a conviction. Multiple Facts objects should represent multiple offences or offenders.\n\nclass Facts:\n    def __init__(self, \n                 victim_category: str, \n                 offence_date: str, \n                 jurisdiction: str, \n                 actions: list = None, \n                 role: list = None\n                ):\n        self.victim_category = victim_category\n        self.offence_date = offence_date\n        self.jurisdiction = jurisdiction\n        self.actions = actions if actions is not None else []\n        self.role = role if role is not None else []"
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#rules.py",
    "href": "posts/basic-statutory-expert-system/index.html#rules.py",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "rules.py",
    "text": "rules.py\nOnce the factual matrix is put together, the program calls a rules function on those facts. This function first checks to see if the complainant_key matches either of the complainant categories in HIGH_TREASON_RULES. If so, the program checks to see if any of the facts attached to that key match the offence facts in HIGH_TREASON_RULES. If so, the function appends them to a list and returns it. If not, the function returns an empty list for the main function to interpret as a null result.\n\ndef high_treason_rules(facts):\n    matches = []  # create an empty list to hold matches\n    for action in facts.actions:\n        complainant_key = action[0] \n        action_value = action[1]\n\n        if complainant_key in HIGH_TREASON_RULES:\n            tuple_list = HIGH_TREASON_RULES[complainant_key]\n            for item in tuple_list:\n                if action_value == item[1]:\n                    matches.append(item)  # append the matching item to the list\n    return matches  # return the list of matches"
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#input_correction.py",
    "href": "posts/basic-statutory-expert-system/index.html#input_correction.py",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "input_correction.py",
    "text": "input_correction.py\nThese assumptions assume imperfect input for the victim category and try to anticipate some synonymous terms.\n\ndef standardize_sovereign_names(name):\n    known_aliases = ('queen', 'king', 'queen elizabeth', 'king charles')\n    if name.lower() in known_aliases:\n        return 'sovereign'\n    else:\n        return name\n\ndef standardize_canada_names(name):\n    known_aliases = ('nation of canada', 'canadian people', 'canadian military')\n    if name.lower() in known_aliases:\n        return 'canada'\n    else:\n        return name"
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#main.py",
    "href": "posts/basic-statutory-expert-system/index.html#main.py",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "main.py",
    "text": "main.py\nThe program’s main function. It creates a Facts object and checks the factual matrix against the high treason rules system.\n\ndef create_facts():\n    print(\"Please enter the facts of the case:\")\n\n    victim_category = input(\"Who is the victim? \")\n    victim_category = standardize_sovereign_names(victim_category)\n    victim_category = standardize_canada_names(victim_category)\n    complainant = Complainant(victim_category)\n\n    offence_date = input(\"Date of the offence (YYYY-MM-DD): \")\n    jurisdiction = input(\"Jurisdiction: \")\n\n    actions = high_treason_facts(victim_category)\n\n    return Facts(complainant.name, offence_date, jurisdiction, actions)\n\ndef verify_high_treason(matches):\n    if matches:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)\n    else:\n        print(\"No offence detected.\")\n\ndef high_treason_system():\n\n    facts = create_facts()\n    matches = high_treason_rules(facts)\n    \n    verify_high_treason(matches)\n    \n    return matches\n\nAnd that’s it! We have the beginnings of a primitive expert legal system. I will continue developing this code in subsequent blog posts, though I may occasionally return here to update the code. Refer to the GitHub repo for version history, as needed."
  },
  {
    "objectID": "posts/basic-statutory-expert-system/index.html#footnotes",
    "href": "posts/basic-statutory-expert-system/index.html#footnotes",
    "title": "BSES part 1: a basic statutory expert system",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee http://www.doc.ic.ac.uk/~rak/papers/British%20Nationality%20Act.pdf↩︎\nSee e.g. AI & Law: British Nationality Act Unexpectedly Spurred AI And Law, How the British Nationality Act Served to Inadvertently Spur AI and the Law.↩︎\nCompare Criminal Code, 1952 s 46(1) with Aidan R. Vining, “Reforming Canadian Sentencing Practices: Problems, Prospects and Lessons” (1979) 17:2 Osgoode Hall L J 355 at note 116.↩︎\nThe other historically capital offences were murder and rape.↩︎\nSee e.g. https://en.wikibooks.org/wiki/Canadian_Criminal_Law/Proof_of_Elements↩︎"
  },
  {
    "objectID": "posts/jurisdiction_verification/index.html",
    "href": "posts/jurisdiction_verification/index.html",
    "title": "BSES part 2: adding jurisdictional functionality",
    "section": "",
    "text": "Some text."
  },
  {
    "objectID": "posts/todo/index.html",
    "href": "posts/todo/index.html",
    "title": "TODO",
    "section": "",
    "text": "Items that need attention sooner than later.\n\n\n\nSinclair\nImmigration\nNolo contendere\n\n\n\n\n\nHigh treason\n\nJurisdiction\n\n“In Canada” requirement\n\nPunishment\nProcedure\n\nTreason\n\nOffence elements\n\nHistoric\n\nTreason case history\n\nStatutory (if applicable)\nCommon law\n\nHigh treason case history (if applicable)"
  },
  {
    "objectID": "posts/todo/index.html#articles",
    "href": "posts/todo/index.html#articles",
    "title": "TODO",
    "section": "",
    "text": "Sinclair\nImmigration\nNolo contendere"
  },
  {
    "objectID": "posts/todo/index.html#bses",
    "href": "posts/todo/index.html#bses",
    "title": "TODO",
    "section": "",
    "text": "High treason\n\nJurisdiction\n\n“In Canada” requirement\n\nPunishment\nProcedure\n\nTreason\n\nOffence elements\n\nHistoric\n\nTreason case history\n\nStatutory (if applicable)\nCommon law\n\nHigh treason case history (if applicable)"
  },
  {
    "objectID": "notebooks/bses_1_clean.html",
    "href": "notebooks/bses_1_clean.html",
    "title": "Criminal Code s 46 expert system example",
    "section": "",
    "text": "This file contains the questions that, once answered, can generate the factual matrix needed to determine whether the defendant committed high treason. The conditional flow is clumsy, but the questions employed that way for now may be useful for GPT-3.5-style prompts at a later point.\n\nHIGH_TREASON_RULES = {\n    \"sovereign\": [(\"Did the defendant kill the sovereign?\",\n                   [\"kill\"]),\n                  (\"Did the defendant attempt to kill the sovereign?\",\n                   [\"kill\", \"attempt\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause death?\",\n                   [\"bodily harm\", \"tending to death\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause destruction?\",\n                   [\"bodily harm\", \"tending to destruction\"]),\n                  (\"Did the defendant maim the sovereign?\",\n                   [\"maim\"]),\n                  (\"Did the defendant wound the sovereign?\",\n                   [\"wound\"]),\n                  (\"Did the defendant imprison the sovereign?\",\n                   [\"imprison\"]),\n                  (\"Did the defendant restrain the sovereign?\",\n                   [\"restrain\"])],\n    \"canada\": [(\"Did the defendant levy war against Canada?\",\n                [\"levy war\"]),\n               (\"Did the defendant prepare to levy war against Canada?\",\n                [\"prepare\", \"levy war\"]),\n               (\"Did the defendant assist an enemy at war with Canada?\",\n                [\"assist warring enemy\"]),\n               (\"Did the defendant assist an armed force hostily engaged with Canadian Forces?\",\n                [\"assist hostile force\"])]}"
  },
  {
    "objectID": "notebooks/bses_1_clean.html#rules_constants.py",
    "href": "notebooks/bses_1_clean.html#rules_constants.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "",
    "text": "This file contains the questions that, once answered, can generate the factual matrix needed to determine whether the defendant committed high treason. The conditional flow is clumsy, but the questions employed that way for now may be useful for GPT-3.5-style prompts at a later point.\n\nHIGH_TREASON_RULES = {\n    \"sovereign\": [(\"Did the defendant kill the sovereign?\",\n                   [\"kill\"]),\n                  (\"Did the defendant attempt to kill the sovereign?\",\n                   [\"kill\", \"attempt\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause death?\",\n                   [\"bodily harm\", \"tending to death\"]),\n                  (\"Did the defendant do bodily harm to the sovereign tending to cause destruction?\",\n                   [\"bodily harm\", \"tending to destruction\"]),\n                  (\"Did the defendant maim the sovereign?\",\n                   [\"maim\"]),\n                  (\"Did the defendant wound the sovereign?\",\n                   [\"wound\"]),\n                  (\"Did the defendant imprison the sovereign?\",\n                   [\"imprison\"]),\n                  (\"Did the defendant restrain the sovereign?\",\n                   [\"restrain\"])],\n    \"canada\": [(\"Did the defendant levy war against Canada?\",\n                [\"levy war\"]),\n               (\"Did the defendant prepare to levy war against Canada?\",\n                [\"prepare\", \"levy war\"]),\n               (\"Did the defendant assist an enemy at war with Canada?\",\n                [\"assist warring enemy\"]),\n               (\"Did the defendant assist an armed force hostily engaged with Canadian Forces?\",\n                [\"assist hostile force\"])]}"
  },
  {
    "objectID": "notebooks/bses_1_clean.html#facts.py",
    "href": "notebooks/bses_1_clean.html#facts.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "facts.py",
    "text": "facts.py\n'''\nGenerates a factual matrix that can be used to determine whether the facts of\nthe case make out a particular offence.\n'''\nAt first glance there may be some advantage to having the get_actions() functions return True/False, rather than a list. After all, if any one condition is met, the defendant committed high treason. But this overlooks the fact that a defendant may have committed the same offence through different means. A person who levies war against Canada AND assists a separate armed force hostily engaged with Canadian Forces commits high treason twice. Similarly, a person may have caused the sovereign bodily harm that amounts to both maiming and bodily harm tending to cause death, and can be fairly charged and tried for both offences (albeit not convicted of both, per Stinchcombe.) A list allows the program to record multiple offence instances using fewer passes. Lists save time and ensure the program remains extensible.\n\ndef get_sovereign_actions() -&gt; list:\n    \"\"\"\n    Ask the user questions related to actions against the sovereign.\n    \"\"\"\n\n    actions = []\n    for question in HIGH_TREASON_RULES[\"sovereign\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"sovereign\", question[1]))\n    \n    return actions\n\n\ndef get_canada_actions() -&gt; list:\n    \"\"\"\n    Ask the user questions related to actions against Canada.\n    \"\"\"\n\n    actions = []\n    for question in HIGH_TREASON_RULES[\"canada\"]:\n        response = input(question[0] + \" (yes/no): \")\n        if response.lower() == 'yes':\n            actions.append((\"canada\", question[1]))\n\n    return actions\n\ndef high_treason_facts(victim_category) -&gt; list:\n    \"\"\"\n    Asks the user questions to determine if the facts of the case make out the offence of high treason.\n    \"\"\"\n    actions = []\n\n    if victim_category.lower() == 'sovereign':\n        actions = get_sovereign_actions()\n    elif victim_category.lower() == 'canada':\n        actions = get_canada_actions()\n\n    return actions"
  },
  {
    "objectID": "notebooks/bses_1_clean.html#models.py",
    "href": "notebooks/bses_1_clean.html#models.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "models.py",
    "text": "models.py\nOnce the program gathers this information, it needs a place to store it. The Facts class takes this job on. The version below contemplates a few variables that aren’t in use yet. Because this class is currently being used for just one offence, it only needs to be able to store the victim category and the defendant’s actions.\n\nclass Facts:\n    \"\"\"\n    A basic class capable of handling the minimum facts required for a high \n    treason offence.\n\n    Attributes:\n        victim_category (str): The name of the victim of the offence.\n        offence_date (str): The date of the offence.\n        jurisdiction (str): The jurisdiction in which the offence took place.\n        actions (list): A list of actions that the defendant took against the \n            victim.\n        role (list): A list of roles that the defendant played in the offence.\n\n    A Facts object should account for one offence and offender. Any potential\n    path to a conviction should be represented by a distinct Facts object. \n    Multiple offences or offenders should be represented by multiple Facts \n    objects.\n    \"\"\"\n\n    def __init__(self, \n                 victim_category: str, \n                 offence_date: str, \n                 jurisdiction: str, \n                 actions: list = None, \n                 role: list = None\n                ):\n        self.victim_category = victim_category\n        self.offence_date = offence_date\n        self.jurisdiction = jurisdiction\n        self.actions = actions if actions is not None else []\n        self.role = role if role is not None else []"
  },
  {
    "objectID": "notebooks/bses_1_clean.html#rules.py",
    "href": "notebooks/bses_1_clean.html#rules.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "rules.py",
    "text": "rules.py\nOnce the factual matrix is put together, the program calls a rules function on those facts. This function first checks to see if the complainant_key matches either of the complainant categories in HIGH_TREASON_RULES. If so, the program checks to see if any of the facts attached to that key match the offence facts in HIGH_TREASON_RULES. If so, the function appends them to a list and returns it. If not, the function returns an empty list for the main function to interpret as a null result.\n\n'''\nRules determining whether a factual matrix corresponds to offence elements.\n'''\n\ndef high_treason_rules(facts):\n    \"\"\"\n    Checks if the facts of the case make out the offence of high treason.\n    \"\"\"\n    matches = []  # create an empty list to hold matches\n\n    # Check if any of the actions in the facts are in the list of high treason actions\n    for action in facts.actions:\n        complainant_key = action[0] \n        action_value = action[1]\n\n        if complainant_key in HIGH_TREASON_RULES: # Checks to see if the complainant category lines up with one of the two in HIGH_TREASON RULES\n            tuple_list = HIGH_TREASON_RULES[complainant_key]\n            for item in tuple_list:\n                if action_value == item[1]:\n                    matches.append(item)  # append the matching item to the list\n    return matches  # return the list of matches"
  },
  {
    "objectID": "notebooks/bses_1_clean.html#dev_models.py",
    "href": "notebooks/bses_1_clean.html#dev_models.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "dev_models.py",
    "text": "dev_models.py\nThese models weren’t used to develop the first few versions of the high treason system, but models like this will be needed to extend the system to other offences. It may be needed to extend the high treason system to account for elements like jurisdiction, punishment, procedure, etc.\n\nclass Complainant:\n    \"\"\"\n    Creates a complainant instance. \n    \"\"\"\n    def __init__(self, name=None, age=None, category=None):\n        self.name = name\n        self.age = age\n        self.category = category\n\nclass Defendant:\n    \"\"\"\n    Creates a defendant instance. Necessary to the extent that some offences \n    only apply to defendants with certain characteristics, and to the extent\n    that some offences will involve multiple defendants who need to be kept\n    distinct from one another.\n    \"\"\"\n    def __init__(self, name=None, age=None, liability=None, criminal_record=None):\n        self.name = name\n        self.age = age\n        self.liability = liability\n        self.criminal_record = criminal_record"
  },
  {
    "objectID": "notebooks/bses_1_clean.html#input_correction.py",
    "href": "notebooks/bses_1_clean.html#input_correction.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "input_correction.py",
    "text": "input_correction.py\n\n\"\"\"\nFunctions used to process input strings and correct them to a standard format.\n\"\"\"\n\n# High treason\n\ndef standardize_sovereign_names(name):\n    \"\"\"\n    This function takes a name and standardizes it to 'Sovereign' if it matches any of the known aliases.\n    \"\"\"\n    known_aliases = ('queen', 'king', 'queen elizabeth', 'king charles')\n    if name.lower() in known_aliases:\n        return 'sovereign'\n    else:\n        return name\n\ndef standardize_canada_names(name):\n    \"\"\"\n    This function takes a name and standardizes it to 'Canada' if it matches any of the known aliases.\n    \"\"\"\n    known_aliases = ('nation of canada', 'canadian people', 'canadian military')\n    if name.lower() in known_aliases:\n        return 'canada'\n    else:\n        return name\n\n# Treason\n\ndef treason_location_type(input_string: str) -&gt; str:\n    \"\"\"\n    This function helps determine whether a string entity is a province or a \n    federally-regulated territory for the purpose of determining whether a \n    defendant has committed treason.\n    \"\"\"\n    input_string = input_string.replace('.', '')  # Remove periods from input\n\n    # Dictionary mapping province names, abbreviations and territory names, abbreviations to their corresponding types\n    locations = {\n        \"alberta\": \"province\",\n        \"ab\": \"province\",\n        \"alta\": \"province\",\n        \"british columbia\": \"province\",\n        \"bc\": \"province\",\n        \"manitoba\": \"province\",\n        \"mb\": \"province\",\n        \"man\": \"province\",\n        \"new brunswick\": \"province\",\n        \"nb\": \"province\",\n        \"newfoundland and labrador\": \"province\",\n        \"nl\": \"province\",\n        \"nova scotia\": \"province\",\n        \"ns\": \"province\",\n        \"ontario\": \"province\",\n        \"on\": \"province\",\n        \"ont\": \"province\",\n        \"prince edward island\": \"province\",\n        \"pei\": \"province\",\n        \"quebec\": \"province\",\n        \"qc\": \"province\",\n        \"que\": \"province\",\n        \"saskatchewan\": \"province\",\n        \"sk\": \"province\",\n        \"sask\": \"province\",\n        \"northwest territories\": \"canada\",\n        \"nt\": \"canada\",\n        \"nwt\": \"canada\",\n        \"nunavut\": \"canada\",\n        \"nu\": \"canada\",\n        \"nvt\": \"canada\",\n        \"yukon\": \"canada\",\n        \"yt\": \"canada\"\n    }\n\n    # Return the corresponding value if the input string is in the dictionary, else return \"Unknown\"\n    return locations.get(input_string.lower(), \"Unknown\")"
  },
  {
    "objectID": "notebooks/bses_1_clean.html#main.py",
    "href": "notebooks/bses_1_clean.html#main.py",
    "title": "Criminal Code s 46 expert system example",
    "section": "main.py",
    "text": "main.py\nThis function executes the program. It creates a Facts object by canvassing the minimum number of questions for the offence’s factual matrix. Once created, Facts is passed to the rules set which returns the final result.\nThe function is limited to high treason as defined in Criminal Code s 46, and thus has this rule set coded into tthe function. Future versions should modularize this rule set call.\n\ndef create_facts():\n    \"\"\"\n    Creates a Facts object that can then be read using the rule base.\n    \"\"\"\n\n    print(\"Please enter the facts of the case:\")\n\n    victim_category = input(\"Who is the victim? \")\n    victim_category = standardize_sovereign_names(victim_category)\n    victim_category = standardize_canada_names(victim_category)\n    complainant = Complainant(victim_category)\n\n    offence_date = input(\"Date of the offence (YYYY-MM-DD): \")\n    jurisdiction = input(\"Jurisdiction: \")\n\n    actions = high_treason_facts(victim_category)\n\n    return Facts(complainant.name, offence_date, jurisdiction, actions)\n\ndef verify_high_treason(matches):\n    if matches:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)\n    else:\n        print(\"No offence detected.\")\n\ndef high_treason_system():\n\n    facts = create_facts()\n    matches = high_treason_rules(facts)\n    verify_high_treason(matches)\n    \n    return matches"
  },
  {
    "objectID": "notebooks/bses_4.html",
    "href": "notebooks/bses_4.html",
    "title": "# Basic statutory expert system 4 — procedure",
    "section": "",
    "text": "CC s 7\n\nCC s 7(2.33) — Consent of Attorney General of Canada\nNo proceedings in relation to an offence referred to in subsection (2.3) or (2.31) may be instituted without the consent of the Attorney General of Canada.\n\n\nCC s 7(2.37) Consent of Attorney General of Canada\nNo proceedings in relation to an offence referred to in subsection (2.35) or (2.36) may be instituted without the consent of the Attorney General of Canada.\nJurisdiction\n\nWhere a person is alleged to have committed an act or omission that is an offence by virtue of this section, proceedings in respect of that offence may, whether or not that person is in Canada, be commenced in any territorial division in Canada and the accused may be tried and punished in respect of that offence in the same manner as if the offence had been committed in that territorial division.\n\nIf previously tried outside Canada\n\nIf a person is alleged to have committed an act or omission that is an offence by virtue of this section and that person has been tried and dealt with outside Canada in respect of the offence in such a manner that, if that person had been tried and dealt with in Canada, they would be able to plead autrefois acquit,autrefois convict, pardon or an expungement order under the Expungement of Historically Unjust Convictions Act, that person shall be deemed to have been so tried and dealt with in Canada.\n\nCC s 469\n469 Every court of criminal jurisdiction has jurisdiction to try an indictable offence other than\n\nan offence under any of the following sections:\nsection 47 (treason) — punishment section for treason and high treason alike\n\nIndictment for treason\n\nIf an accused is charged with an offence under section 47 or sections 50 to 53, every overt act that is to be relied on shall be stated in the indictment.\n\n\n\nCC 582 — High treason and first degree murder\n582 No person shall be convicted for the offence of high treason or first degree murder unless in the indictment charging the offence he is specifically charged with that offence.\n\n\nCC 601(9) — Amending defective indictment or court — Limitation\n(9) The authority of a court to amend indictments does not authorize the court to add to the overt acts stated in an indictment for high treason or treason or for an offence against any provision in sections 50, 51 and 53.\n\n\nCC 515 — Judicial interim release — Detention in custody for offence listed in section 469\n(11) Where an accused who is charged with an offence mentioned in section 469 is taken before a justice, the justice shall order that the accused be detained in custody until he is dealt with according to law and shall issue a warrant in Form 8 for the committal of the accused.\n\n\nCC 522 — Interim release by judge only\n(1) Where an accused is charged with an offence listed in section 469, no court, judge or justice, other than a judge of or a judge presiding in a superior court of criminal jurisdiction for the province in which the accused is so charged, may release the accused before or after the accused has been ordered to stand trial.\n\n(2) Where an accused is charged with an offence listed in section 469, a judge of or a judge presiding in a superior court of criminal jurisdiction for the province in which the accused is charged shall order that the accused be detained in custody unless the accused, having been given a reasonable opportunity to do so, shows cause why his detention in custody is not justified within the meaning of subsection 515(10).\n\nOther offences\n\n(6) Where an accused is charged with an offence mentioned in section 469 and with any other offence, a judge acting under this section may apply the provisions of this Part respecting judicial interim release to that other offence.\n\n\nCC 523 — Order vacating previous order for release or detention\n(2) Despite subsections (1) to (1.2),\n\n    (ii) where the accused is charged with an offence listed in section 469, a judge of or a judge presiding in a superior court of criminal jurisdiction for the province, ... \n\nmay, on cause being shown, vacate any order previously made under this Part for the interim release or detention of the accused and make any other order provided for in this Part for the detention or release of the accused until his trial is completed that the court, judge or justice considers to be warranted.\n\nProvisions applicable to proceedings under subsection (2)\n\n(3) The provisions of sections 517, 518 and 519 apply, with such modifications as the circumstances require, in respect of any proceedings under subsection (2), except that subsection 518(2) does not apply in respect of an accused who is charged with an offence listed in section 469.\nApplication for judicial review\n745.6 (1) Subject to subsections (2) to (2.6), a person may apply, in writing, to the appropriate Chief Justice in the province in which their conviction took place for a reduction in the number of years of imprisonment without eligibility for parole if the person\n\nhas been convicted of murder or high treason;\n\n(a.1) committed the murder or high treason before the day on which this paragraph comes into force;\n\nhas been sentenced to imprisonment for life without eligibility for parole until more than fifteen years of their sentence has been served; and\nhas served at least fifteen years of their sentence.\n\nLess than 15 years of sentence served\n(2.1) A person who is convicted of murder or high treason and who has served less than 15 years of their sentence on the day on which this subsection comes into force may, within 90 days after the day on which they have served 15 years of their sentence, make an application under subsection (1).\nAt least 15 years of sentence served\n(2.2) A person who is convicted of murder or high treason and who has served at least 15 years of their sentence on the day on which this subsection comes into force may make an application under subsection (1) within 90 days after\n\nthe end of five years after the day on which the person was the subject of a determination made under subsection 745.61(4) or a determination or conclusion to which subsection 745.63(8) applies; or\nthe day on which this subsection comes into force, if the person has not made an application under subsection (1).\n\nRequest for preliminary inquiry\n\nIf an accused referred to in subsection (2) elects to be tried by a judge without a jury or by a court composed of a judge and jury or does not elect when put to the election or is deemed under paragraph 565(1)(a) to have elected to be tried by a court composed of a judge and jury, or if an accused is charged with an offence listed in section 469 that is punishable by 14 years or more of imprisonment, the justice shall, subject to section 577, on the request of the accused or the prosecutor made at that time or within the period fixed by rules of court made under section 482 or 482.1 or, if there are no such rules, by the justice, hold a preliminary inquiry into the charge.\n\nEndorsement on the information — other accused charged with an offence punishable by 14 years or more of imprisonment\n(4.11) If an accused is before a justice, charged with an offence listed in section 469 that is punishable by 14 years or more of imprisonment, the justice shall endorse on the information and, if the accused is in custody, on the warrant of remand, a statement showing whether the accused or the prosecutor has requested that a preliminary inquiry be held.\nRequest for preliminary inquiry — Nunavut\n\nIf an accused referred to in subsection (2) elects to be tried by a judge without a jury or by a court composed of a judge and jury or does not elect when put to the election or is deemed under paragraph 565(1)(a) to have elected to be tried by a court composed of a judge and jury or if an accused is charged with an offence listed in section 469 that is punishable by 14 years or more of imprisonment, the justice or judge shall, subject to section 577, on the request of the accused or the prosecutor made at that time or within the period fixed by rules of court made under section 482 or 482.1 or, if there are no such rules, by the judge or justice, hold a preliminary inquiry into the charge."
  },
  {
    "objectID": "posts/bses-2-jurisdiction/index.html",
    "href": "posts/bses-2-jurisdiction/index.html",
    "title": "BSES part 2: adding jurisdictional functionality",
    "section": "",
    "text": "For a defendant to be guilty of a Canadian criminal offence, the offence must have been committed “in Canada.” In most cases, determining whether a crime was committed in Canada is straightforward. But in rare instances, Canada will have jurisdiction over a crime committed outside Canada. In these cases, Canadian jurisdiction must either be constructed or waived. The next set of functions goes through the necessary steps to determine whether an offence was committed “in Canada,” with an extensive focus on constructive jurisdiction.\n\n\nBefore delving into constructive jurisdiction, I outline a general system for dealing with jurisdiction. The first (and most straightforward) way to understand an offender committing an offence “in Canada” is for that offence to have geographically occurred in Canada. In virtually every case, the crime will allegedly have happened in Canada geographically, so it is crucial to implement this functionality early on. Doing so requires another set of constants and some code to use the Facts.jurisdiction attribute.\n\nCANADIAN_PROVINCES: dict[str, tuple[str, str]] = {\n    'Alberta': ('AB', 'Alta'),\n    'British Columbia': ('BC', 'B.C.'),\n    'Manitoba': ('MB', 'Man.'),\n    'New Brunswick': ('NB', 'N.B.'),\n    'Newfoundland and Labrador': ('NL', 'N.L.'),\n    'Nova Scotia': ('NS', 'N.S.'),\n    'Ontario': ('ON', 'Ont.'),\n    'Prince Edward Island': ('PE', 'P.E.I.'),\n    'Quebec': ('QC', 'Que.'),\n    'Saskatchewan': ('SK', 'Sask.')\n}\n\nCANADIAN_TERRITORIES: dict[str, tuple[str, str]] = {\n    'Northwest Territories': ('NT', 'N.W.T.'),\n    'Nunavut': ('NU', 'Nvt.'),\n    'Yukon': ('YT', 'Y.T.')\n}\n\n\n\n\nWith that preliminary jurisdictional matrix implemented, the next step is determining whether the jurisdiction entered matches one of the geographical Canadian jurisdictions. Legal jurisdiction is not something inherent to the offence itself or the defendant. Rather, jurisdiction is primarily determined based on the location of the crime. It therefore makes sense to situate jurisdictional functions within the Facts class.[^1]\n\n\nThe verify_canadian_jurisdiction() function checks whether the given jurisdiction string matches any Canadian provincial, territorial, or federal jurisdiction. If so, the function determines that the offence occurred “in Canada,” thus making out general jurisdiction.\n\n\n\nPreviously, the create_facts function was part of the main.py program execution file. While this was sufficient for a minimally-viable product, more workable solutions exist. For example, there will be times when we want the program to run without having to go through a lengthy checklist of questions, especially when the user may enter that information directly into a Facts class object.\nFor now, the create_facts method can continue to have high_treason_facts assigned to it through hard coding. I will eventually start siphoning off processes related to high treason and other offences into separate functions and possibly a separate Offence class.\n\n\n\n\nThe code thus far covers geographical jurisdiction. But the jurisdictional question still needs to be fully resolved. In rare circumstances, the Criminal Code allows the court to construe Canadian jurisdiction constructively, even if an offence didn’t occur “in Canada.” Furthermore, for certain classes of people, the jurisdictional requirement for high treason is waived, while for other categories of people, Canadian jurisdiction may exist regardless of where a defendant commits an offence. These edge cases include:\n\nPublic Service employees. Public Service employees are deemed to have committed an offence in Canada regardless of where they committed it.\nCanadian citizens and allegiance-owers. For treason and high treason specifically, a Canadian citizen, or anyone who owes allegiance to the sovereign, will have committed treason or high treason regardless of whether the jurisdictional component obtains. Unlike Public Service employees, who have jurisdiction constructed regardless of where they commit crimes, this exception obviates the jurisdictional requirement.\nAircraft, spacecraft, the space station and the lunar surface. Crimes committed in specific unorthodox locations will be deemed committed in Canada if certain conditions obtain. The requirements and exceptions are several, as will be seen below.\n\n\n\nPublic Service employees are a unique class in the Criminal Code, in that they alone are deemed to have committed an offence “in Canada” regardless of where they commit a crime. They appear to be the only class singled out in this way in the Criminal Code. The statutory authority for this also extends to another act — the Public Service Employment Act, SC 2003, c 22, ss 12, 13.\n\n\n\nEvery one who, while employed as an employee within the meaning of the Public Service Employment Act in a place outside Canada, commits an act or omission in that place that is an offence under the laws of that place and that, if committed in Canada, would be an offence punishable by indictment shall be deemed to have committed that act or omission in Canada.\n\n\n\n\n\nemployee means a person employed in that part of the public service to which the Commission has exclusive authority to make appointments. (fonctionnaire)\n\n\n\n\n\nExcept as provided in this Act, the Commission has the exclusive authority to make appointments, to or from within the public service, of persons for whose appointment there is no authority in or under any other Act of Parliament.\n\nDetermining who exactly qualifies as a Public Service employee, then, requires that:\n\nThey are a public service employee;\nThe Public Service Commission may appoint that employee; and\nNo other [federal] statutory authority exists to appoint that employee.\n\n\nPUBLIC_EMPLOYEE_CRITERIA = (\"Is the defendant a public service employee?\",\n                            \"Does the Public Service Commission have the authority to appoint the defendant?\",\n                            \"Does any other federal statute confer authority to appoint the defendant?\")\n\nOTHER_ACTS_OF_PARLIAMENT = {\n    \n}\n\n\n\n\n\nIff all three indices are True, the individual is a Public Service employee within the meaning of the PSEA and the Criminal Code. But answering this question correctly requires additional knowledge about the Public Service Commission’s exclusive authority, which in turn requires additional knowledge about the scope of all other Acts of Parliament that cordon off appointment authority, if any. While I don’t know whether there are any such statutes, I’ve built the function to incorporate them if they exist. If they don’t, adding this functionality can help future-proof the function if Parliament passes any such acts in the future.\nWe can incorporate these questions into a simple UI method for the Defendant class that determines whether a person is a public employee, as the Criminal Code understands the term. The function returns True iff all conditions presented are True.\n\n    def public_employee_test(self):\n        \"\"\"\n        Verifies whether a defendant is a public employee as understood by the \n        Criminal Code.\n        \"\"\"\n        \n        for question in PUBLIC_EMPLOYEE_CRITERIA:\n            response = input(question + \" (yes/no): \")\n            if response.strip().lower() != 'yes':\n                return\n        self.vocation.append(\"public employee\")\n\n\n\n\n\n\n\nNotwithstanding subsection (1) or (2), a Canadian citizen or a person who owes allegiance to Her Majesty in right of Canada,\n\n    (a) commits high treason if, while in or out of Canada, he does anything mentioned in subsection (1); or\n\n    (b) commits treason if, while in or out of Canada, he does anything mentioned in subsection (2).\n\nBecause the statute doesn’t define allegiance, I must make some assumptions. Primarily, I assume that a person owes allegiance to the sovereign iff they are a Commonwealth country citizen. If this theory holds, we can use a dictionary to check whether a defendant owes allegiance to the sovereign. This dictionary lists demonyms as values and tuples containing country names as keys. Because Canada is also a Commonwealth country, distinguishing the two programmatically is optional.\n\nCOMMONWEALTH_DEMONYMS = {\n    \"antigua and barbuda\": [\"antiguan\", \n                            \"barbudan\"],\n    \"australia\": [\"australian\"],\n    \"the bahamas\": [\"bahamian\"],\n    \"bangladesh\": [\"bangladeshi\"],\n    \"barbados\": [\"barbadian\", \n                 \"bajan\"],\n    \"belize\": [\"belizean\"],\n    \"botswana\": [\"botswanan\"],\n    \"brunei darussalam\": [\"bruneian\"],\n    \"cameroon\": [\"cameroonian\"],\n    \"canada\": [\"canadian\"],\n    \"cyprus\": [\"cypriot\"],\n    \"dominica\": [\"dominican\",\n                 \"dominican commonwealth\"],\n    \"eswatini\": [\"swazi\"],\n    \"fiji\": [\"fijian\"],\n    \"gambia\": [\"gambian\"],\n    \"ghana\": [\"ghanaian\"],\n    \"grenada\": [\"grenadian\"],\n    \"guyana\": [\"guyanese\"],\n    \"india\": [\"indian\"],\n    \"jamaica\": [\"jamaican\"],\n    \"kenya\": [\"kenyan\"],\n    \"kiribati\": [\"i-kiribati\"],\n    \"lesotho\": [\"mosotho\", \n                \"basotho\"],\n    \"malawi\": [\"malawian\"],\n    \"malaysia\": [\"malaysian\"],\n    \"maldives\": [\"maldivian\"],\n    \"malta\": [\"maltese\"],\n    \"mauritius\": [\"mauritian\"],\n    \"mozambique\": [\"mozambican\"],\n    \"namibia\": [\"namibian\"],\n    \"nauru\": [\"nauruan\"],\n    \"new zealand\": [\"new zealander\", \n                    \"kiwi\"],\n    \"nigeria\": [\"nigerian\"],\n    \"pakistan\": [\"pakistani\"],\n    \"papua new guinea\": [\"papuan\", \n                         \"guinean\"],\n    \"rwanda\": [\"rwandan\"],\n    \"saint lucia\": [\"saint lucian\"],\n    \"samoa\": [\"samoan\"],\n    \"seychelles\": [\"seychellois\"],\n    \"sierra leone\": [\"sierra leonean\"],\n    \"singapore\": [\"singaporean\"],\n    \"solomon islands\": [\"solomon islander\"],\n    \"south africa\": [\"south african\"],\n    \"sri lanka\": [\"sri lankan\"],\n    \"st kitts and nevis\": [\"kittitian\", \"nevisian\"],\n    \"st vincent and the grenadines\": [\"vincentian\"],\n    \"tanzania\": [\"tanzanian\"],\n    \"tonga\": [\"tongan\"],\n    \"trinidad and tobago\": [\"trinidadian\", \n                            \"tobagonian\"],\n    \"tuvalu\": [\"tuvaluan\"],\n    \"uganda\": [\"ugandan\"],\n    \"united kingdom\": [\"british\", \n                       \"english\", \n                       \"scottish\", \n                       \"welsh\", \n                       \"northern irish\"],\n    \"vanuatu\": [\"vanuatuan\"],\n    \"zambia\": [\"zambian\"],\n}\n\n\n\n\nWith this list in place, I next need to code a function that can check a defendant’s citizenship attribute against this dictionary to determine whether they owe the sovereign allegiance. Because a defendant’s citizenship is generally an attribute about them and not about the offence’s facts, it makes sense to turn this into a Defendant attribute. But because the allegiance question so rarely comes up, future iterations of the Defendant class may move this function into an Offence function or out into the general namespace.\n\ndef allegiance_test(self):\n    \"\"\"\n    Determines whether a defendant owes allegiance to the sovereign based\n    on their citizenship. The method iterates over the list of citizenships\n    and checks each one. If the individual has \"dominican\" citizenship, \n    the program must further determine whether the individual is a citizen\n    of Dominica (Commonwealth) or the Dominican Republic (not Commonwealth).\n\n    For \"dominican\" citizenship, it invokes the _handle_dominican method to handle\n    the special case. For other citizenships, it checks if they are Commonwealth\n    using the _is_commonwealth_citizen method.\n\n    If it finds Commonwealth citizenship, it immediately returns True. If none \n    of the citizenships are Commonwealth, it returns False. If the citizenship list is \n    empty or not provided, it also returns False.\n\n    Returns:\n        bool: True if the defendant has Commonwealth citizenship, False otherwise.\n    \"\"\"\n\n    if self.citizenship:\n        for i, citizenship in enumerate(self.citizenship):\n            if citizenship.lower() == \"dominican\":\n                self.citizenship[i] = self._handle_dominican()\n                citizenship = self.citizenship[i]  # update citizenship value with new string\n\n            if self._is_commonwealth_citizen(citizenship):\n                return True\n        return False\n    else:\n        return False\n\n\n\n\nTesting for a defendant’s allegiance contemplates two private methods: namely, the _handle_dominican() method and the _is_commonwealth_citizen() method. _is_commonwealth_citizen() checks whether a given citizenship belongs to a Commonwealth country, while _handle_dominican() prompts the user for more input if a defendant has “dominican” citizenship. This is because a “Dominican” citizen may be from the Dominican Republic, which is not a Commonwealth country, or Dominica, which is. I’ve coded these methods as follows:\n\n    def _is_commonwealth_citizen(self, citizenship):\n        \"\"\"\n        A private method that checks if a given citizenship belongs to a \n        Commonwealth country.\n\n        Args:\n            citizenship (str): The citizenship string to check. This should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if the citizenship is in the list of Commonwealth countries \n            or demonyms, False otherwise.\n\n        Note:\n            This method assumes that `COMMONWEALTH_DEMONYMS` is a dictionary \n            available in the global scope, where the keys are countries and \n            the values are lists of associated demonyms.\n        \"\"\"\n        \n        return any(citizenship.lower() in demonyms for demonyms in COMMONWEALTH_DEMONYMS.values())\n    \n    def _handle_dominican(self):\n        \"\"\"\n        This is a private method that checks if a \"dominican\" citizenship belongs \n        to the Commonwealth country Dominica or the non-Commonwealth country, \n        the Dominican Republic.\n\n        Args:\n            index (int): The \"dominican\" citizenship index in the citizenship list.\n\n        Returns:\n            None\n        \"\"\"\n        \n        while True:\n            print(\"Are you from (1) Dominica or (2) the Dominican Republic?\")\n            response = input(\"Please enter 1 or 2: \").strip()\n            if response == \"1\":\n                return \"dominican commonwealth\"\n            elif response == \"2\":\n                return \"dominican not commonwealth\"\n            else:\n                print(\"Invalid input. Please enter 1 or 2.\")\n\n\n\n\n\nThe final step in settling jurisdiction is to deal with offences committed on aircraft, spacecraft, the ISS, the Lunar Gateway, or the lunar surface. Although the high treason system uses the code here, it may have a broader application later within future Criminal Code offences. This general application notwithstanding, this jurisdictional section is unlikely to capture much criminal activity.\nConceptually, these different locales are divisible into two distinct groups:\n\nAircraft offences\nSpacecraft, the ISS, the Lunar Gateway, and the lunar surface\n\nThe main difference between these two groups is the Partner State consideration in the latter group.\n\n\n\nNotwithstanding anything in this Act or any other Act, every one who\n\n     (a) on or in respect of an aircraft\n\n          (i) registered in Canada under regulations made under the Aeronautics Act, or\n          (ii) leased without crew and operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations,\n\n  while the aircraft is in flight, or\n\n      (b) on any aircraft, while the aircraft is in flight if the flight terminated in Canada,\n\ncommits an act or omission in or outside Canada that if committed in Canada would be an offence punishable by indictment shall be deemed to have committed that act or omission in Canada.\n\n\n\n\nTo deal with the complexities of jurisdiction for offences committed in aircraft, verify_constructive_jurisdiction_aircraft() tests for constructive jurisdiction. The Criminal Code for aircraft establishes Canadian jurisdiction when an aircraft is registered in Canada, terminates in Canada, or is legally leased in Canada, per the following control flow:\n\nThe defendant is deemed to have committed an offence in Canada if:\n\nThe defendant committed an offence on an aircraft in flight AND\nThe aircraft was registered in Canada under regulations made under the Aeronautics Act OR\nThe aircraft was leased without crew AND operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as the owner of an aircraft registered in Canada under those regulations OR\nThe flight terminated in Canada\n\n\nI’ve codified this control flow as a Facts class method, adding constructive jurisdiction to a case’s facts if sufficient facts exist to do so.\n\ndef verify_constructive_jurisdiction_aircraft(self):\n    \"\"\"\n    Verifies whether an offence committed on an aircraft falls under Canadian jurisdiction and updates the jurisdiction attribute accordingly.\n\n    This method asks the user a series of questions to determine if the offence falls under the Canadian statute when committed on an aircraft. If it does, the jurisdiction is updated to include the specific location.\n\n    Note:\n        This method uses the `input` function in an interactive context.\n    \"\"\"\n\n    deemed_jurisdiction = []\n\n    offense_committed = verify_yes_no(\"Was the offense committed on an aircraft in flight? (yes/no): \")\n    aircraft_registered = aircraft_leased = qualified_operator = flight_terminated = False\n\n    if offense_committed:\n        flight_terminated = verify_yes_no(\"Did the flight terminate in Canada? (yes/no): \")\n        aircraft_registered = verify_yes_no(\"Is the aircraft\\n * Registered in Canada under regulations made under the Aeronautics Act? (yes/no): \")\n        aircraft_leased = verify_yes_no(\" * Leased without crew operated by a person qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n    if aircraft_leased:\n        qualified_operator = verify_yes_no(\" * Operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n\n\n    if aircraft_registered:\n        deemed_jurisdiction.append(\"deemed jurisdiction (legally registered aircraft)\")\n    if aircraft_leased and qualified_operator:\n        deemed_jurisdiction.append(\"deemed jurisdiction (legally leased and operated aircraft)\")\n    if flight_terminated:\n        deemed_jurisdiction.append(\"deemed jurisdiction (flight terminated in Canada)\")\n\n    for item in deemed_jurisdiction:\n        if item not in self.jurisdiction:\n            self.jurisdiction.append(item)\n\n\n\n\nThis section applies to Canadian crew members during space flights involving the International Space Station. The Criminal Code deems any action or inaction by a Canadian crew member during such flights that would constitute an indictable offence in Canada to have been committed within Canada.\n\nDespite anything in this Act or any other Act, a Canadian crew member who, during a space flight, commits an act or omission outside Canada that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission is committed\n\n       (a) on, or in relation to, a flight element of the Space Station; or\n       (b) on any means of transportation to or from the Space Station.\n\n\n\n\nThis section expands the principle to include Partner States crew members and applies when a defendant commits an act or omission that would constitute an indictable offence in Canada during a space flight involving the International Space Station.\n\nDespite anything in this Act or any other Act, a crew member of a Partner State who commits an act or omission outside Canada during a space flight on, or in relation to, a flight element of the Space Station or on any means of transportation to and from the Space Station that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission\n\n       (a) threatens the life or security of a Canadian crew member; or\n       (b) is committed on or in relation to, or damages, a flight element provided by Canada.\n\n\n\n\nSimilar provisions apply to Canadian crew members during space flights involving the Lunar Gateway or the lunar surface.\n\nDespite anything in this Act or any other Act, a Canadian crew member who, during a space flight, commits an act or omission outside Canada that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission is committed\n\n   (a) on, or in relation to, a flight element of the Lunar Gateway;\n\n   (b) on any means of transportation to or from the Lunar Gateway; or\n\n   (c) on the surface of the Moon.\n\n\n\n\nFinally, crew members of Partner States involved in space flights to or from the Lunar Gateway or on the lunar surface are subject to the same principles of constructive jurisdiction if their actions or omissions would constitute an indictable offence in Canada.\n\nDespite anything in this Act or any other Act, a crew member of a Partner State who commits an act or omission outside Canada during a space flight on, or in relation to, a flight element of the Lunar Gateway, on any means of transportation to and from the Lunar Gateway or on the surface of the Moon that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission\n\n   (a) threatens the life or security of a Canadian crew member; or\n\n   (b) is committed on or in relation to, or damages, a flight element provided by Canada.\n\nThis decision tree structure outlines the conditions that would extend Canadian jurisdiction to actions committed in space, including the International Space Station (ISS), Lunar Gateway, and the lunar surface. The control flow starts with determining whether the actor is a member or authorized agent of a Partner State.\nUnder this structure, for each possible location (ISS, en route to/from ISS, Lunar Gateway, en route to/from Lunar Gateway, and the lunar surface), the methods consider a range of offences, including actions that threaten the life or security of a Canadian crew member, damage a flight element provided by Canada, or are conducted concerning such a flight element:\n\nVerify if the actor is a member or authorized agent of a Partner State.\nIf yes, determine the location of the offence (ISS, en route to/from ISS, Lunar Gateway, en route to/from Lunar Gateway, lunar surface).\nAt each location, check if the defendant committed an offence which:\n\nThreatens the life or security of a Canadian crew member,\nIs in relation to or damages a flight element provided by Canada.\n\n\n\n\n\nThe complexity of these control flows requires a systematic approach to determining jurisdiction. The verify_constructive_jurisdiction_space() facilitates this purpose by prompting the user with questions to assess whether a crew member’s actions fall within Canadian jurisdiction according to the criteria outlined in these sections. The function itself encapsulates our decision tree. The corresponding method assesses each offence and location if the defendant is a Partner State member:\n\n    def verify_constructive_jurisdiction_space(self):\n        # List of possible locations\n        locations = [\"on the iss\", \n                     \"en route to iss\", \n                     \"on the lunar gateway\", \n                     \"en route to/from Lunar Gateway\", \n                     \"on the lunar surface\"]\n\n        # Combine all offences into one list\n        all_offences = [\"threatend a canadian crew member's life\", \n                        \"threatend a canadian crew member's security\", \n                        \"damaged a canadian flight element\", \n                        \"offended in relation to a canadian flight element\",\n                        \"damaged a canadian flight element\"]\n\n        partner_state_member = self._verify_partner_state(defendant.agency)\n        \n        if partner_state_member:\n            for offence in all_offences:\n                print(f\"The defendant {offence} — (yes/no): \")\n                offence_committed = input().lower()\n                if offence_committed == 'yes':\n                    for location in locations:\n                        print(f\"Did the offence take place {location}? (yes/no): \")\n                        offence_location = input().lower()\n                        if offence_location == 'yes':\n                            self.jurisdiction.append(f\"deemed jurisdiction ({offence} {location})\")\n\n\n\n\nThe code above contemplates a private _verify_partner_state() function and an agency variable. Partner State membership is not tied to citizenship. Instead, a person is statutorily a member of a Partner State if they are a crew member of a Partner State. To the extent that a person can be a crew member acting for a Partner State and not a citizen of that country, the two are conceptually distinct through an agency variable.\nTo verify Partner States, however, I must first outline what constitutes a Partner State.\n\n\n\n\nAgreement has the same meaning as in section 2 of the Civil International Space Station Agreement Implementation Act.\n…\nPartner State means a State, other than Canada, who contracted to enter into the Agreement and for which the Agreement has entered into force in accordance with article 25 of the Agreement.\n\nThe pertinent section of Civil International Space Station Agreement Implementation Act art 25 reads as follows:\n\n\nThis Agreement shall remain open for signature by the States listed in the Preamble of this Agreement.\n\n\nThe Preamble then outlines the fact that Partner States are\n\nAn Act to implement the Agreement among the Government of Canada, Governments of Member States of the European Space Agency, the Government of Japan, the Government of the Russian Federation, and the Government of the United States of America concerning Cooperation on the Civil International Space Station and to make related amendments to other Acts.\n\nGiven the above information, a partner state is:\n\nCanada\nJapan;\nThe Russian Federation;\nThe United States of America; or\nA member state of the ESA\n\nESA member states include:\n\nAustria\nBelgium\nCzech Republic\nDenmark\nEstonia\nFinland\nFrance\nGermany\nGreece\nHungary\nIreland\nItaly\nLuxembourg\nNetherlands\nNorway\nPoland\nPortugal\nRomania\nSpain\nSweden\nSwitzerland\nUnited Kingdom\n\nThese can be expressed as Python dictionaries, just as I did with the Commonwealth countries above:\n\nNON_ESA_PARTNER_STATE_DEMONYMS = {\n    \"canada\": (\"canadian\",),\n    \"japan\": (\"japanese\",),\n    \"russian federation\": (\"russian\",),\n    \"united states of america\": (\"american\",)\n}\n\nESA_PARTNER_STATE_DEMONYMS = {\n    \"austria\": (\"austrian\",),\n    \"belgium\": (\"belgian\",),\n    \"czech republic\": (\"czech\", \"czechoslovakian\"),\n    \"denmark\": (\"danish\",),\n    \"estonia\": (\"estonian\",),\n    \"finland\": (\"finnish\",),\n    \"france\": (\"french\",),\n    \"germany\": (\"german\",),\n    \"greece\": (\"greek\",),\n    \"hungary\": (\"hungarian\",),\n    \"ireland\": (\"irish\",),\n    \"italy\": (\"italian\",),\n    \"luxembourg\": (\"luxembourger\",),\n    \"netherlands\": (\"dutch\",),\n    \"norway\": (\"norwegian\",),\n    \"poland\": (\"polish\",),\n    \"portugal\": (\"portuguese\",),\n    \"romania\": (\"romanian\",),\n    \"spain\": (\"spanish\",),\n    \"sweden\": (\"swedish\",),\n    \"switzerland\": (\"swiss\",),\n    \"united kingdom\": (\"british\", \"scottish\", \"english\", \"welsh\", \"irish\")\n}\n\n\n\n\nOnce the Partner States are archived in the dictionary, we need a method to determine whether a particular defendant’s agency variable correlates to a Partner State value:\n\n    def _verify_partner_state(self, memberships):\n        \"\"\"\n        This is a private method that checks if any given citizenship belongs to a \n        Partner State country.\n\n        Args:\n            citizenships (list): The list of citizenships to check. Each should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if any of the citizenships is in the list of Partner States' countries \n            or demonyms, False otherwise.\n        \"\"\"\n\n        # Convert the dictionary values (which are tuples) into sets for easy searching\n        non_esa_demonyms = set(val for sublist in NON_ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n        esa_demonyms = set(val for sublist in ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n\n        for membership in memberships:\n            if membership in non_esa_demonyms or membership in esa_demonyms:\n                return True\n\n        return False\n\n\n\n\n\n\nThe final step is to code a function that will check to determine whether there is jurisdiction for an offence by checking both Facts and Defendant objects to see whether the jurisdictional preconditions are met. Because high treason has its own form of constructive jurisdiction, the control flow will have to account for that:\n\nIs the offence committed in Canada?\n\nIs the defendant jurisdictionally exempt?\nCan jurisdiction be constructed?\n\nAircraft jurisdiction\nSpace jurisdiction\n\nIs the offence treason?\n\nDoes the defendant owe allegiance to Canada?\n\n\n\nThe verify_high_treason() function determines whether the offence is made out. The previous verify_high_treason() function simply checked to see if matches had any content. If it did, it would print them out. But jurisdiction introduces a new issue: we can’t say a defendant committed high treason unless we also establish that the offence occurred in Canada. We must expand ``verify_high_treason()```’s scope to do this. For now, this function is class-independent.[^2]\n\ndef verify_high_treason(matches, facts, defendant):\n    \"\"\"\n    Determines whether the factual and legal matrix is sufficient to make out \n    high treason.\n    \"\"\"\n    \n    reasons = []\n\n    if not matches:\n        reasons.append(\"* No wrongful act\")\n\n    # Check allegiance\n    if not defendant.allegiance_test():\n        reasons.append(\"* Defendant does not owe allegiance to the sovereign\")\n\n    # If defendant doesn't owe allegiance, then we also check for jurisdiction\n    if not defendant.allegiance_test() and facts.jurisdiction == \"not recognized\":\n        reasons.append(\"* No jurisdiction\")\n\n    # If there are any reasons in the list, print them out. \n    # Otherwise, high treason has been committed.\n    if reasons:\n        print(\"High treason not committed:\")\n        for reason in reasons:\n            print(reason)\n    else:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)\n\n\n\n\nThe basic statutory expert system now accounts for jurisdiction and high treason’s offence elements. The next step will be to create functions that allow the program to deal with case law, interpretive ambiguities, and legal uncertainties.\nIn the first post, I cited high treason’s limited case law base as a reason for building an expert system around it. Because case law introduces new legal rules, nuances, definitions, and applications, accounting for case law necessarily complicates statutory interpretation control flow. Bypassing these complications for a minimally-viable product is a sensible way to start. But once we have that MVP, we need a system that accounts for legal ambiguities and tells the user when more than one conclusion is possible. Because high treason has limited court consideration, these potential complications will be much fewer than those introduced in frequently-charged offences.\n[^1] As the system develops, jurisdiction may become a more significant issue. If that proves to be the case, jurisdictional functions will likely have to move to a separate class. For now, treating them as just another fact makes sense. [^2] See note 1 above. The same logic applies to stray functions that deal with individual offences. How these are best dealt with is still very much to be determined."
  },
  {
    "objectID": "posts/bses-2-jurisdiction/index.html#canadian-jurisdictions",
    "href": "posts/bses-2-jurisdiction/index.html#canadian-jurisdictions",
    "title": "BSES part 2: adding jurisdictional functionality",
    "section": "",
    "text": "Before delving into constructive jurisdiction, I outline a general system for dealing with jurisdiction. The first (and most straightforward) way to understand an offender committing an offence “in Canada” is for that offence to have geographically occurred in Canada. In virtually every case, the crime will allegedly have happened in Canada geographically, so it is crucial to implement this functionality early on. Doing so requires another set of constants and some code to use the Facts.jurisdiction attribute.\n\nCANADIAN_PROVINCES: dict[str, tuple[str, str]] = {\n    'Alberta': ('AB', 'Alta'),\n    'British Columbia': ('BC', 'B.C.'),\n    'Manitoba': ('MB', 'Man.'),\n    'New Brunswick': ('NB', 'N.B.'),\n    'Newfoundland and Labrador': ('NL', 'N.L.'),\n    'Nova Scotia': ('NS', 'N.S.'),\n    'Ontario': ('ON', 'Ont.'),\n    'Prince Edward Island': ('PE', 'P.E.I.'),\n    'Quebec': ('QC', 'Que.'),\n    'Saskatchewan': ('SK', 'Sask.')\n}\n\nCANADIAN_TERRITORIES: dict[str, tuple[str, str]] = {\n    'Northwest Territories': ('NT', 'N.W.T.'),\n    'Nunavut': ('NU', 'Nvt.'),\n    'Yukon': ('YT', 'Y.T.')\n}"
  },
  {
    "objectID": "posts/bses-2-jurisdiction/index.html#jurisdiction-verification",
    "href": "posts/bses-2-jurisdiction/index.html#jurisdiction-verification",
    "title": "BSES part 2: adding jurisdictional functionality",
    "section": "",
    "text": "With that preliminary jurisdictional matrix implemented, the next step is determining whether the jurisdiction entered matches one of the geographical Canadian jurisdictions. Legal jurisdiction is not something inherent to the offence itself or the defendant. Rather, jurisdiction is primarily determined based on the location of the crime. It therefore makes sense to situate jurisdictional functions within the Facts class.[^1]\n\n\nThe verify_canadian_jurisdiction() function checks whether the given jurisdiction string matches any Canadian provincial, territorial, or federal jurisdiction. If so, the function determines that the offence occurred “in Canada,” thus making out general jurisdiction.\n\n\n\nPreviously, the create_facts function was part of the main.py program execution file. While this was sufficient for a minimally-viable product, more workable solutions exist. For example, there will be times when we want the program to run without having to go through a lengthy checklist of questions, especially when the user may enter that information directly into a Facts class object.\nFor now, the create_facts method can continue to have high_treason_facts assigned to it through hard coding. I will eventually start siphoning off processes related to high treason and other offences into separate functions and possibly a separate Offence class."
  },
  {
    "objectID": "posts/bses-2-jurisdiction/index.html#constructive-jurisdiction",
    "href": "posts/bses-2-jurisdiction/index.html#constructive-jurisdiction",
    "title": "BSES part 2: adding jurisdictional functionality",
    "section": "",
    "text": "The code thus far covers geographical jurisdiction. But the jurisdictional question still needs to be fully resolved. In rare circumstances, the Criminal Code allows the court to construe Canadian jurisdiction constructively, even if an offence didn’t occur “in Canada.” Furthermore, for certain classes of people, the jurisdictional requirement for high treason is waived, while for other categories of people, Canadian jurisdiction may exist regardless of where a defendant commits an offence. These edge cases include:\n\nPublic Service employees. Public Service employees are deemed to have committed an offence in Canada regardless of where they committed it.\nCanadian citizens and allegiance-owers. For treason and high treason specifically, a Canadian citizen, or anyone who owes allegiance to the sovereign, will have committed treason or high treason regardless of whether the jurisdictional component obtains. Unlike Public Service employees, who have jurisdiction constructed regardless of where they commit crimes, this exception obviates the jurisdictional requirement.\nAircraft, spacecraft, the space station and the lunar surface. Crimes committed in specific unorthodox locations will be deemed committed in Canada if certain conditions obtain. The requirements and exceptions are several, as will be seen below.\n\n\n\nPublic Service employees are a unique class in the Criminal Code, in that they alone are deemed to have committed an offence “in Canada” regardless of where they commit a crime. They appear to be the only class singled out in this way in the Criminal Code. The statutory authority for this also extends to another act — the Public Service Employment Act, SC 2003, c 22, ss 12, 13.\n\n\n\nEvery one who, while employed as an employee within the meaning of the Public Service Employment Act in a place outside Canada, commits an act or omission in that place that is an offence under the laws of that place and that, if committed in Canada, would be an offence punishable by indictment shall be deemed to have committed that act or omission in Canada.\n\n\n\n\n\nemployee means a person employed in that part of the public service to which the Commission has exclusive authority to make appointments. (fonctionnaire)\n\n\n\n\n\nExcept as provided in this Act, the Commission has the exclusive authority to make appointments, to or from within the public service, of persons for whose appointment there is no authority in or under any other Act of Parliament.\n\nDetermining who exactly qualifies as a Public Service employee, then, requires that:\n\nThey are a public service employee;\nThe Public Service Commission may appoint that employee; and\nNo other [federal] statutory authority exists to appoint that employee.\n\n\nPUBLIC_EMPLOYEE_CRITERIA = (\"Is the defendant a public service employee?\",\n                            \"Does the Public Service Commission have the authority to appoint the defendant?\",\n                            \"Does any other federal statute confer authority to appoint the defendant?\")\n\nOTHER_ACTS_OF_PARLIAMENT = {\n    \n}\n\n\n\n\n\nIff all three indices are True, the individual is a Public Service employee within the meaning of the PSEA and the Criminal Code. But answering this question correctly requires additional knowledge about the Public Service Commission’s exclusive authority, which in turn requires additional knowledge about the scope of all other Acts of Parliament that cordon off appointment authority, if any. While I don’t know whether there are any such statutes, I’ve built the function to incorporate them if they exist. If they don’t, adding this functionality can help future-proof the function if Parliament passes any such acts in the future.\nWe can incorporate these questions into a simple UI method for the Defendant class that determines whether a person is a public employee, as the Criminal Code understands the term. The function returns True iff all conditions presented are True.\n\n    def public_employee_test(self):\n        \"\"\"\n        Verifies whether a defendant is a public employee as understood by the \n        Criminal Code.\n        \"\"\"\n        \n        for question in PUBLIC_EMPLOYEE_CRITERIA:\n            response = input(question + \" (yes/no): \")\n            if response.strip().lower() != 'yes':\n                return\n        self.vocation.append(\"public employee\")\n\n\n\n\n\n\n\nNotwithstanding subsection (1) or (2), a Canadian citizen or a person who owes allegiance to Her Majesty in right of Canada,\n\n    (a) commits high treason if, while in or out of Canada, he does anything mentioned in subsection (1); or\n\n    (b) commits treason if, while in or out of Canada, he does anything mentioned in subsection (2).\n\nBecause the statute doesn’t define allegiance, I must make some assumptions. Primarily, I assume that a person owes allegiance to the sovereign iff they are a Commonwealth country citizen. If this theory holds, we can use a dictionary to check whether a defendant owes allegiance to the sovereign. This dictionary lists demonyms as values and tuples containing country names as keys. Because Canada is also a Commonwealth country, distinguishing the two programmatically is optional.\n\nCOMMONWEALTH_DEMONYMS = {\n    \"antigua and barbuda\": [\"antiguan\", \n                            \"barbudan\"],\n    \"australia\": [\"australian\"],\n    \"the bahamas\": [\"bahamian\"],\n    \"bangladesh\": [\"bangladeshi\"],\n    \"barbados\": [\"barbadian\", \n                 \"bajan\"],\n    \"belize\": [\"belizean\"],\n    \"botswana\": [\"botswanan\"],\n    \"brunei darussalam\": [\"bruneian\"],\n    \"cameroon\": [\"cameroonian\"],\n    \"canada\": [\"canadian\"],\n    \"cyprus\": [\"cypriot\"],\n    \"dominica\": [\"dominican\",\n                 \"dominican commonwealth\"],\n    \"eswatini\": [\"swazi\"],\n    \"fiji\": [\"fijian\"],\n    \"gambia\": [\"gambian\"],\n    \"ghana\": [\"ghanaian\"],\n    \"grenada\": [\"grenadian\"],\n    \"guyana\": [\"guyanese\"],\n    \"india\": [\"indian\"],\n    \"jamaica\": [\"jamaican\"],\n    \"kenya\": [\"kenyan\"],\n    \"kiribati\": [\"i-kiribati\"],\n    \"lesotho\": [\"mosotho\", \n                \"basotho\"],\n    \"malawi\": [\"malawian\"],\n    \"malaysia\": [\"malaysian\"],\n    \"maldives\": [\"maldivian\"],\n    \"malta\": [\"maltese\"],\n    \"mauritius\": [\"mauritian\"],\n    \"mozambique\": [\"mozambican\"],\n    \"namibia\": [\"namibian\"],\n    \"nauru\": [\"nauruan\"],\n    \"new zealand\": [\"new zealander\", \n                    \"kiwi\"],\n    \"nigeria\": [\"nigerian\"],\n    \"pakistan\": [\"pakistani\"],\n    \"papua new guinea\": [\"papuan\", \n                         \"guinean\"],\n    \"rwanda\": [\"rwandan\"],\n    \"saint lucia\": [\"saint lucian\"],\n    \"samoa\": [\"samoan\"],\n    \"seychelles\": [\"seychellois\"],\n    \"sierra leone\": [\"sierra leonean\"],\n    \"singapore\": [\"singaporean\"],\n    \"solomon islands\": [\"solomon islander\"],\n    \"south africa\": [\"south african\"],\n    \"sri lanka\": [\"sri lankan\"],\n    \"st kitts and nevis\": [\"kittitian\", \"nevisian\"],\n    \"st vincent and the grenadines\": [\"vincentian\"],\n    \"tanzania\": [\"tanzanian\"],\n    \"tonga\": [\"tongan\"],\n    \"trinidad and tobago\": [\"trinidadian\", \n                            \"tobagonian\"],\n    \"tuvalu\": [\"tuvaluan\"],\n    \"uganda\": [\"ugandan\"],\n    \"united kingdom\": [\"british\", \n                       \"english\", \n                       \"scottish\", \n                       \"welsh\", \n                       \"northern irish\"],\n    \"vanuatu\": [\"vanuatuan\"],\n    \"zambia\": [\"zambian\"],\n}\n\n\n\n\nWith this list in place, I next need to code a function that can check a defendant’s citizenship attribute against this dictionary to determine whether they owe the sovereign allegiance. Because a defendant’s citizenship is generally an attribute about them and not about the offence’s facts, it makes sense to turn this into a Defendant attribute. But because the allegiance question so rarely comes up, future iterations of the Defendant class may move this function into an Offence function or out into the general namespace.\n\ndef allegiance_test(self):\n    \"\"\"\n    Determines whether a defendant owes allegiance to the sovereign based\n    on their citizenship. The method iterates over the list of citizenships\n    and checks each one. If the individual has \"dominican\" citizenship, \n    the program must further determine whether the individual is a citizen\n    of Dominica (Commonwealth) or the Dominican Republic (not Commonwealth).\n\n    For \"dominican\" citizenship, it invokes the _handle_dominican method to handle\n    the special case. For other citizenships, it checks if they are Commonwealth\n    using the _is_commonwealth_citizen method.\n\n    If it finds Commonwealth citizenship, it immediately returns True. If none \n    of the citizenships are Commonwealth, it returns False. If the citizenship list is \n    empty or not provided, it also returns False.\n\n    Returns:\n        bool: True if the defendant has Commonwealth citizenship, False otherwise.\n    \"\"\"\n\n    if self.citizenship:\n        for i, citizenship in enumerate(self.citizenship):\n            if citizenship.lower() == \"dominican\":\n                self.citizenship[i] = self._handle_dominican()\n                citizenship = self.citizenship[i]  # update citizenship value with new string\n\n            if self._is_commonwealth_citizen(citizenship):\n                return True\n        return False\n    else:\n        return False\n\n\n\n\nTesting for a defendant’s allegiance contemplates two private methods: namely, the _handle_dominican() method and the _is_commonwealth_citizen() method. _is_commonwealth_citizen() checks whether a given citizenship belongs to a Commonwealth country, while _handle_dominican() prompts the user for more input if a defendant has “dominican” citizenship. This is because a “Dominican” citizen may be from the Dominican Republic, which is not a Commonwealth country, or Dominica, which is. I’ve coded these methods as follows:\n\n    def _is_commonwealth_citizen(self, citizenship):\n        \"\"\"\n        A private method that checks if a given citizenship belongs to a \n        Commonwealth country.\n\n        Args:\n            citizenship (str): The citizenship string to check. This should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if the citizenship is in the list of Commonwealth countries \n            or demonyms, False otherwise.\n\n        Note:\n            This method assumes that `COMMONWEALTH_DEMONYMS` is a dictionary \n            available in the global scope, where the keys are countries and \n            the values are lists of associated demonyms.\n        \"\"\"\n        \n        return any(citizenship.lower() in demonyms for demonyms in COMMONWEALTH_DEMONYMS.values())\n    \n    def _handle_dominican(self):\n        \"\"\"\n        This is a private method that checks if a \"dominican\" citizenship belongs \n        to the Commonwealth country Dominica or the non-Commonwealth country, \n        the Dominican Republic.\n\n        Args:\n            index (int): The \"dominican\" citizenship index in the citizenship list.\n\n        Returns:\n            None\n        \"\"\"\n        \n        while True:\n            print(\"Are you from (1) Dominica or (2) the Dominican Republic?\")\n            response = input(\"Please enter 1 or 2: \").strip()\n            if response == \"1\":\n                return \"dominican commonwealth\"\n            elif response == \"2\":\n                return \"dominican not commonwealth\"\n            else:\n                print(\"Invalid input. Please enter 1 or 2.\")\n\n\n\n\n\nThe final step in settling jurisdiction is to deal with offences committed on aircraft, spacecraft, the ISS, the Lunar Gateway, or the lunar surface. Although the high treason system uses the code here, it may have a broader application later within future Criminal Code offences. This general application notwithstanding, this jurisdictional section is unlikely to capture much criminal activity.\nConceptually, these different locales are divisible into two distinct groups:\n\nAircraft offences\nSpacecraft, the ISS, the Lunar Gateway, and the lunar surface\n\nThe main difference between these two groups is the Partner State consideration in the latter group.\n\n\n\nNotwithstanding anything in this Act or any other Act, every one who\n\n     (a) on or in respect of an aircraft\n\n          (i) registered in Canada under regulations made under the Aeronautics Act, or\n          (ii) leased without crew and operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations,\n\n  while the aircraft is in flight, or\n\n      (b) on any aircraft, while the aircraft is in flight if the flight terminated in Canada,\n\ncommits an act or omission in or outside Canada that if committed in Canada would be an offence punishable by indictment shall be deemed to have committed that act or omission in Canada.\n\n\n\n\nTo deal with the complexities of jurisdiction for offences committed in aircraft, verify_constructive_jurisdiction_aircraft() tests for constructive jurisdiction. The Criminal Code for aircraft establishes Canadian jurisdiction when an aircraft is registered in Canada, terminates in Canada, or is legally leased in Canada, per the following control flow:\n\nThe defendant is deemed to have committed an offence in Canada if:\n\nThe defendant committed an offence on an aircraft in flight AND\nThe aircraft was registered in Canada under regulations made under the Aeronautics Act OR\nThe aircraft was leased without crew AND operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as the owner of an aircraft registered in Canada under those regulations OR\nThe flight terminated in Canada\n\n\nI’ve codified this control flow as a Facts class method, adding constructive jurisdiction to a case’s facts if sufficient facts exist to do so.\n\ndef verify_constructive_jurisdiction_aircraft(self):\n    \"\"\"\n    Verifies whether an offence committed on an aircraft falls under Canadian jurisdiction and updates the jurisdiction attribute accordingly.\n\n    This method asks the user a series of questions to determine if the offence falls under the Canadian statute when committed on an aircraft. If it does, the jurisdiction is updated to include the specific location.\n\n    Note:\n        This method uses the `input` function in an interactive context.\n    \"\"\"\n\n    deemed_jurisdiction = []\n\n    offense_committed = verify_yes_no(\"Was the offense committed on an aircraft in flight? (yes/no): \")\n    aircraft_registered = aircraft_leased = qualified_operator = flight_terminated = False\n\n    if offense_committed:\n        flight_terminated = verify_yes_no(\"Did the flight terminate in Canada? (yes/no): \")\n        aircraft_registered = verify_yes_no(\"Is the aircraft\\n * Registered in Canada under regulations made under the Aeronautics Act? (yes/no): \")\n        aircraft_leased = verify_yes_no(\" * Leased without crew operated by a person qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n    if aircraft_leased:\n        qualified_operator = verify_yes_no(\" * Operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n\n\n    if aircraft_registered:\n        deemed_jurisdiction.append(\"deemed jurisdiction (legally registered aircraft)\")\n    if aircraft_leased and qualified_operator:\n        deemed_jurisdiction.append(\"deemed jurisdiction (legally leased and operated aircraft)\")\n    if flight_terminated:\n        deemed_jurisdiction.append(\"deemed jurisdiction (flight terminated in Canada)\")\n\n    for item in deemed_jurisdiction:\n        if item not in self.jurisdiction:\n            self.jurisdiction.append(item)\n\n\n\n\nThis section applies to Canadian crew members during space flights involving the International Space Station. The Criminal Code deems any action or inaction by a Canadian crew member during such flights that would constitute an indictable offence in Canada to have been committed within Canada.\n\nDespite anything in this Act or any other Act, a Canadian crew member who, during a space flight, commits an act or omission outside Canada that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission is committed\n\n       (a) on, or in relation to, a flight element of the Space Station; or\n       (b) on any means of transportation to or from the Space Station.\n\n\n\n\nThis section expands the principle to include Partner States crew members and applies when a defendant commits an act or omission that would constitute an indictable offence in Canada during a space flight involving the International Space Station.\n\nDespite anything in this Act or any other Act, a crew member of a Partner State who commits an act or omission outside Canada during a space flight on, or in relation to, a flight element of the Space Station or on any means of transportation to and from the Space Station that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission\n\n       (a) threatens the life or security of a Canadian crew member; or\n       (b) is committed on or in relation to, or damages, a flight element provided by Canada.\n\n\n\n\nSimilar provisions apply to Canadian crew members during space flights involving the Lunar Gateway or the lunar surface.\n\nDespite anything in this Act or any other Act, a Canadian crew member who, during a space flight, commits an act or omission outside Canada that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission is committed\n\n   (a) on, or in relation to, a flight element of the Lunar Gateway;\n\n   (b) on any means of transportation to or from the Lunar Gateway; or\n\n   (c) on the surface of the Moon.\n\n\n\n\nFinally, crew members of Partner States involved in space flights to or from the Lunar Gateway or on the lunar surface are subject to the same principles of constructive jurisdiction if their actions or omissions would constitute an indictable offence in Canada.\n\nDespite anything in this Act or any other Act, a crew member of a Partner State who commits an act or omission outside Canada during a space flight on, or in relation to, a flight element of the Lunar Gateway, on any means of transportation to and from the Lunar Gateway or on the surface of the Moon that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission\n\n   (a) threatens the life or security of a Canadian crew member; or\n\n   (b) is committed on or in relation to, or damages, a flight element provided by Canada.\n\nThis decision tree structure outlines the conditions that would extend Canadian jurisdiction to actions committed in space, including the International Space Station (ISS), Lunar Gateway, and the lunar surface. The control flow starts with determining whether the actor is a member or authorized agent of a Partner State.\nUnder this structure, for each possible location (ISS, en route to/from ISS, Lunar Gateway, en route to/from Lunar Gateway, and the lunar surface), the methods consider a range of offences, including actions that threaten the life or security of a Canadian crew member, damage a flight element provided by Canada, or are conducted concerning such a flight element:\n\nVerify if the actor is a member or authorized agent of a Partner State.\nIf yes, determine the location of the offence (ISS, en route to/from ISS, Lunar Gateway, en route to/from Lunar Gateway, lunar surface).\nAt each location, check if the defendant committed an offence which:\n\nThreatens the life or security of a Canadian crew member,\nIs in relation to or damages a flight element provided by Canada.\n\n\n\n\n\nThe complexity of these control flows requires a systematic approach to determining jurisdiction. The verify_constructive_jurisdiction_space() facilitates this purpose by prompting the user with questions to assess whether a crew member’s actions fall within Canadian jurisdiction according to the criteria outlined in these sections. The function itself encapsulates our decision tree. The corresponding method assesses each offence and location if the defendant is a Partner State member:\n\n    def verify_constructive_jurisdiction_space(self):\n        # List of possible locations\n        locations = [\"on the iss\", \n                     \"en route to iss\", \n                     \"on the lunar gateway\", \n                     \"en route to/from Lunar Gateway\", \n                     \"on the lunar surface\"]\n\n        # Combine all offences into one list\n        all_offences = [\"threatend a canadian crew member's life\", \n                        \"threatend a canadian crew member's security\", \n                        \"damaged a canadian flight element\", \n                        \"offended in relation to a canadian flight element\",\n                        \"damaged a canadian flight element\"]\n\n        partner_state_member = self._verify_partner_state(defendant.agency)\n        \n        if partner_state_member:\n            for offence in all_offences:\n                print(f\"The defendant {offence} — (yes/no): \")\n                offence_committed = input().lower()\n                if offence_committed == 'yes':\n                    for location in locations:\n                        print(f\"Did the offence take place {location}? (yes/no): \")\n                        offence_location = input().lower()\n                        if offence_location == 'yes':\n                            self.jurisdiction.append(f\"deemed jurisdiction ({offence} {location})\")\n\n\n\n\nThe code above contemplates a private _verify_partner_state() function and an agency variable. Partner State membership is not tied to citizenship. Instead, a person is statutorily a member of a Partner State if they are a crew member of a Partner State. To the extent that a person can be a crew member acting for a Partner State and not a citizen of that country, the two are conceptually distinct through an agency variable.\nTo verify Partner States, however, I must first outline what constitutes a Partner State.\n\n\n\n\nAgreement has the same meaning as in section 2 of the Civil International Space Station Agreement Implementation Act.\n…\nPartner State means a State, other than Canada, who contracted to enter into the Agreement and for which the Agreement has entered into force in accordance with article 25 of the Agreement.\n\nThe pertinent section of Civil International Space Station Agreement Implementation Act art 25 reads as follows:\n\n\nThis Agreement shall remain open for signature by the States listed in the Preamble of this Agreement.\n\n\nThe Preamble then outlines the fact that Partner States are\n\nAn Act to implement the Agreement among the Government of Canada, Governments of Member States of the European Space Agency, the Government of Japan, the Government of the Russian Federation, and the Government of the United States of America concerning Cooperation on the Civil International Space Station and to make related amendments to other Acts.\n\nGiven the above information, a partner state is:\n\nCanada\nJapan;\nThe Russian Federation;\nThe United States of America; or\nA member state of the ESA\n\nESA member states include:\n\nAustria\nBelgium\nCzech Republic\nDenmark\nEstonia\nFinland\nFrance\nGermany\nGreece\nHungary\nIreland\nItaly\nLuxembourg\nNetherlands\nNorway\nPoland\nPortugal\nRomania\nSpain\nSweden\nSwitzerland\nUnited Kingdom\n\nThese can be expressed as Python dictionaries, just as I did with the Commonwealth countries above:\n\nNON_ESA_PARTNER_STATE_DEMONYMS = {\n    \"canada\": (\"canadian\",),\n    \"japan\": (\"japanese\",),\n    \"russian federation\": (\"russian\",),\n    \"united states of america\": (\"american\",)\n}\n\nESA_PARTNER_STATE_DEMONYMS = {\n    \"austria\": (\"austrian\",),\n    \"belgium\": (\"belgian\",),\n    \"czech republic\": (\"czech\", \"czechoslovakian\"),\n    \"denmark\": (\"danish\",),\n    \"estonia\": (\"estonian\",),\n    \"finland\": (\"finnish\",),\n    \"france\": (\"french\",),\n    \"germany\": (\"german\",),\n    \"greece\": (\"greek\",),\n    \"hungary\": (\"hungarian\",),\n    \"ireland\": (\"irish\",),\n    \"italy\": (\"italian\",),\n    \"luxembourg\": (\"luxembourger\",),\n    \"netherlands\": (\"dutch\",),\n    \"norway\": (\"norwegian\",),\n    \"poland\": (\"polish\",),\n    \"portugal\": (\"portuguese\",),\n    \"romania\": (\"romanian\",),\n    \"spain\": (\"spanish\",),\n    \"sweden\": (\"swedish\",),\n    \"switzerland\": (\"swiss\",),\n    \"united kingdom\": (\"british\", \"scottish\", \"english\", \"welsh\", \"irish\")\n}\n\n\n\n\nOnce the Partner States are archived in the dictionary, we need a method to determine whether a particular defendant’s agency variable correlates to a Partner State value:\n\n    def _verify_partner_state(self, memberships):\n        \"\"\"\n        This is a private method that checks if any given citizenship belongs to a \n        Partner State country.\n\n        Args:\n            citizenships (list): The list of citizenships to check. Each should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if any of the citizenships is in the list of Partner States' countries \n            or demonyms, False otherwise.\n        \"\"\"\n\n        # Convert the dictionary values (which are tuples) into sets for easy searching\n        non_esa_demonyms = set(val for sublist in NON_ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n        esa_demonyms = set(val for sublist in ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n\n        for membership in memberships:\n            if membership in non_esa_demonyms or membership in esa_demonyms:\n                return True\n\n        return False"
  },
  {
    "objectID": "posts/bses-2-jurisdiction/index.html#jurisdiction-verification-through-verify_high_treason",
    "href": "posts/bses-2-jurisdiction/index.html#jurisdiction-verification-through-verify_high_treason",
    "title": "BSES part 2: adding jurisdictional functionality",
    "section": "",
    "text": "The final step is to code a function that will check to determine whether there is jurisdiction for an offence by checking both Facts and Defendant objects to see whether the jurisdictional preconditions are met. Because high treason has its own form of constructive jurisdiction, the control flow will have to account for that:\n\nIs the offence committed in Canada?\n\nIs the defendant jurisdictionally exempt?\nCan jurisdiction be constructed?\n\nAircraft jurisdiction\nSpace jurisdiction\n\nIs the offence treason?\n\nDoes the defendant owe allegiance to Canada?\n\n\n\nThe verify_high_treason() function determines whether the offence is made out. The previous verify_high_treason() function simply checked to see if matches had any content. If it did, it would print them out. But jurisdiction introduces a new issue: we can’t say a defendant committed high treason unless we also establish that the offence occurred in Canada. We must expand ``verify_high_treason()```’s scope to do this. For now, this function is class-independent.[^2]\n\ndef verify_high_treason(matches, facts, defendant):\n    \"\"\"\n    Determines whether the factual and legal matrix is sufficient to make out \n    high treason.\n    \"\"\"\n    \n    reasons = []\n\n    if not matches:\n        reasons.append(\"* No wrongful act\")\n\n    # Check allegiance\n    if not defendant.allegiance_test():\n        reasons.append(\"* Defendant does not owe allegiance to the sovereign\")\n\n    # If defendant doesn't owe allegiance, then we also check for jurisdiction\n    if not defendant.allegiance_test() and facts.jurisdiction == \"not recognized\":\n        reasons.append(\"* No jurisdiction\")\n\n    # If there are any reasons in the list, print them out. \n    # Otherwise, high treason has been committed.\n    if reasons:\n        print(\"High treason not committed:\")\n        for reason in reasons:\n            print(reason)\n    else:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)"
  },
  {
    "objectID": "notebooks/bses_2.html",
    "href": "notebooks/bses_2.html",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "",
    "text": "For a defendant to be guilty of a Canadian criminal offence, the offence must have been committed “in Canada.” In most cases, this question is straightforward. But in other cases, Canadian jurisdiction can either be constructed or waived. The next set of functions goes through the necessary steps to determine whether an offence was committed “in Canada.”"
  },
  {
    "objectID": "notebooks/bses_2.html#canadian-jurisdictions",
    "href": "notebooks/bses_2.html#canadian-jurisdictions",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Canadian jurisdictions",
    "text": "Canadian jurisdictions\nThe first (and most straightforward) way to understand what it means for an offender to commit an offence “in Canada” is for that offence to have geographically occurred in Canada. Building this functionality requires another set of constants and some code to use the Facts.jurisdiction attribute.\nCANADIAN_PROVINCES: dict[str, tuple[str, str]] = {\n    'Alberta': ('AB', 'Alta'),\n    'British Columbia': ('BC', 'B.C.'),\n    'Manitoba': ('MB', 'Man.'),\n    'New Brunswick': ('NB', 'N.B.'),\n    'Newfoundland and Labrador': ('NL', 'N.L.'),\n    'Nova Scotia': ('NS', 'N.S.'),\n    'Ontario': ('ON', 'Ont.'),\n    'Prince Edward Island': ('PE', 'P.E.I.'),\n    'Quebec': ('QC', 'Que.'),\n    'Saskatchewan': ('SK', 'Sask.')\n}\n\nCANADIAN_TERRITORIES: dict[str, tuple[str, str]] = {\n    'Northwest Territories': ('NT', 'N.W.T.'),\n    'Nunavut': ('NU', 'Nvt.'),\n    'Yukon': ('YT', 'Y.T.')\n}"
  },
  {
    "objectID": "notebooks/bses_2.html#jurisdiction-verification",
    "href": "notebooks/bses_2.html#jurisdiction-verification",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Jurisdiction verification",
    "text": "Jurisdiction verification\nWith that preliminary jurisdictional matrix in place, the next step is determining whether the jurisdiction entered matches one of the geographical Canadian jurisdictions. Legal jurisdiction refers to the authority or power of a particular court or legal system to hear and decide a case. It is not inherent to the offence itself or the defendant. Rather, jurisdiction is primarily determined based on the location of the crime. It therefore makes sense to situate jurisdictional functions within the Facts class.\n\nHandling geographic jurisdiction via verify_canadian_jurisdiction()\nThe verify_canadian_jurisdiction() function checks whether the given jurisdiction string matches any Canadian provincial, territorial, or federal jurisdiction. If so, the function resolves that the offence occurred “in Canada,” thus making out general jurisdiction.\ndef Facts():\n    \n    ...\n    \n    def verify_canadian_jurisdiction(self,\n                                     jurisdiction: str, \n                                     provinces: dict[str, tuple[str, str]] = CANADIAN_PROVINCES, \n                                     territories: dict[str, tuple[str, str]] = CANADIAN_TERRITORIES) -&gt; tuple[bool, Optional[str]]:\n        \"\"\"\n        This function checks if a given jurisdiction is recognized as part of Canada.\n\n        The function accepts a string representing a jurisdiction and two \n        optional dictionaries representing provinces and territories. Each \n        dictionary maps a region's name to a tuple consisting of its \n        abbreviation and French translation. The function checks if the \n        jurisdiction matches the name, abbreviation, or French translation of \n        any of the provinces or territories. The function also checks if the \n        jurisdiction is \"canada\" or its abbreviation \"ca\".\n\n        If a match is found, the function returns True; otherwise, it returns \n        False.\n\n        Args:\n            jurisdiction (str): The jurisdiction to check.\n            provinces (dict[str, tuple[str, str]], optional): A dictionary of \n            Canadian provinces. Defaults to CANADIAN_PROVINCES.\n            territories (dict[str, tuple[str, str]], optional): A dictionary of\n            Canadian territories. Defaults to CANADIAN_TERRITORIES.\n\n        Returns:\n            tuple[bool, Optional[str]]: A tuple where the first element is a \n            boolean indicating if the jurisdiction is recognized, and the \n            second element is an optional string message.\n        \"\"\"\n        \n        if jurisdiction.lower() in ('canada', 'ca'):\n            return True\n\n        for region in [provinces, territories]:\n            for key, value in region.items():\n                if jurisdiction.lower() in [key.lower(), value[0].lower(), value[1].lower()]:\n                    return True\n        return False\n\n\nUser-generated facts via create_facts()\nPreviously, the create_facts function was part of the main.py program execution file. While this was sufficient for a minimally-viable product, more workable solutions exist. For example, there will be times when we want the program to run without having to go through a lengthy checklist of questions, especially when the user may enter that information directly into a Facts class object.\nFor now, the create_facts method can continue to have high_treason_facts assigned to it through hard coding. I will eventually start siphoning off processes related to high treason and other offences into separate functions and possibly a separate Offence class.\n        def create_facts(self):\n        \"\"\"\n        Interactively collects details about the offence and stores them as instance attributes.\n\n        This method asks the user for details about the victim, offence date, jurisdiction, and actions related to the offence. \n        These details are then stored as instance attributes for future use.\n        \n        Note:\n            This method uses the `input` function and thus is intended for use in an interactive context.\n        \"\"\"\n        \n        print(\"Please enter the facts of the case:\")\n\n        victim_category = input(\"Who is the victim? \")\n        victim_category = standardize_sovereign_names(victim_category)\n        victim_category = standardize_canada_names(victim_category)\n        complainant = Complainant(victim_category)\n\n        offence_date = input(\"Date of the offence (YYYY-MM-DD): \")\n        jurisdiction = input(\"Jurisdiction: \")\n        self.jurisdiction = self.verify_canadian_jurisdiction(jurisdiction)\n\n        actions = high_treason_facts(victim_category)\n\n        self.victim_category = complainant.name\n        self.offence_date = offence_date\n        self.actions = actions"
  },
  {
    "objectID": "notebooks/bses_2.html#constructive-jurisdiction",
    "href": "notebooks/bses_2.html#constructive-jurisdiction",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Constructive jurisdiction",
    "text": "Constructive jurisdiction\nThis code minimally covers geographical jurisdiction. But the jurisdictional question is still not fully resolved. In very particular circumstances, the Criminal Code allows the court to constructively construe Canadian jurisdiction, even if an offence didn’t literally take place “in Canada”. Furthermore, for certain classes of people, the jurisdictional requirement for high treason is waived, while for other classes of people, Canadian jurisdicton can be construed regardless of where an offence is committed. These edge cases can be outlined as follows:\n\nPublic Service employees. Public Service employees are deemed to have committed an offence in Canada regardless of where they actually committed the offence.\nCanadian citizens and allegiance-owers. For treason and high treason specifically, a Canadian citizen, or anyone who owes allegiance to the sovereign, will be considered to have committed treason or high treason, regardless of whether the jurisdictional component is met. Unlike Public Service employees, who have jurisdiction constructed regardless of where they commit crimes, this exception excises the jurisdictional requirement altogether.\nAircraft, spacecraft, the space station and the moon. Crimes committed in certain unorthodox locations will be deemed to have been committed in Canada if certain conditions obtain. The requirements and exceptions are several, as will be seen below.\n\n\nPublic Service employees\nPublic Service employees are a unique class in the Criminal Code, in that they alone are deemed to have committed an offence “in Canada” regardless of where they commit a crime. They appear to be the only class singled out in this way in the Criminal Code. The statutory authority for this also extends to another act — namely, the Public Service Employment Act, SC 2003, c 22, ss 12, 13.\n\nCC s 7(4) — Offences by Public Service employees\n\nEvery one who, while employed as an employee within the meaning of the Public Service Employment Act in a place outside Canada, commits an act or omission in that place that is an offence under the laws of that place and that, if committed in Canada, would be an offence punishable by indictment shall be deemed to have committed that act or omission in Canada.\n\n\n\nPSEA 2(1) — definition: employee\n\nemployee means a person employed in that part of the public service to which the Commission has exclusive authority to make appointments. (fonctionnaire)\n\n\n\nPSEA 29(1) - Commission’s exclusive authority\n\nExcept as provided in this Act, the Commission has the exclusive authority to make appointments, to or from within the public service, of persons for whose appointment there is no authority in or under any other Act of Parliament.\n\nDetermining who exactly qualifies as a Public Service employee, then, requires that:\n\nThey are a public service employee;\nThe Public Service Commission may appoint that employee; and\nThere is no other [federal] statutory authority to appoint that employee.\n\n\n\nQuerying the user about public employment via public_employee_test()\nEach of these points can be expressed as a tuple. Iff (⇔) all three indices are True, the individual is a Public Service employee within the meaning of both the PSEA and the Criminal Code. But answering this question correctly requires additional knowledge about the Public Service Commission’s exclusive authority, which in turn requires additional knowledge about the scope of all other Acts of Parliament that cordon off appointment authority, if any. While I don’t know whether there are any such statutes, the function can be built with an eye towards incorporating these other Acts, if they exist. If they don’t, adding this functionality can help future-proof the function. These constants can be expressed as follows:\nPUBLIC_EMPLOYEE_CRITERIA = (\"Is the defendant a public service employee?\",\n                            \"Does the Public Service Commission have authority to appoint the defendant?\",\n                            \"Does any other federal statute confer authority to appoint the defendant?\")\n\nOTHER_ACTS_OF_PARLIAMENT = {\n    \n}\nThese questions can be incorporated into a quick UI method for the Defendant class that determines whether a person is a public employee, as the Criminal Code understands the term. The function returns True iff all conditions presented are True.\n    def public_employee_test(self):\n        \"\"\"\n        Verifies whether a defendant is a public employee as understood by the \n        Criminal Code.\n        \"\"\"\n        \n        for question in PUBLIC_EMPLOYEE_CRITERIA:\n            response = input(question + \" (yes/no): \")\n            if response.strip().lower() != 'yes':\n                return\n        self.vocation.append(\"public employee\")\n\n\n\nCanadian citizens and allegiance-owers\n\nCC 46(3) — Canadian citizen\n\nNotwithstanding subsection (1) or (2), a Canadian citizen or a person who owes allegiance to Her Majesty in right of Canada,\n\n    (a) commits high treason if, while in or out of Canada, he does anything mentioned in subsection (1); or\n\n    (b) commits treason if, while in or out of Canada, he does anything mentioned in subsection (2).\n\nI assume that a person owes allegiance to the sovereign iff they are a commonwealth country citizen. If this theory holds, we can use a dictionary to check whether a defendant owes allegiance to the sovereign. As citizenship is expressed as a demonym, and as some nations use multiple demonyms, this dictionary uses a list of demonyms as values and tuples containing country names as keys.\nBecause Canada is also a Commonwealth country, it isn’t necessary to distinguish the two programmatically.\nCOMMONWEALTH_DEMONYMS = {\n    \"antigua and barbuda\": [\"antiguan\", \n                            \"barbudan\"],\n    \"australia\": [\"australian\"],\n    \"the bahamas\": [\"bahamian\"],\n    \"bangladesh\": [\"bangladeshi\"],\n    \"barbados\": [\"barbadian\", \n                 \"bajan\"],\n    \"belize\": [\"belizean\"],\n    \"botswana\": [\"botswanan\"],\n    \"brunei darussalam\": [\"bruneian\"],\n    \"cameroon\": [\"cameroonian\"],\n    \"canada\": [\"canadian\"],\n    \"cyprus\": [\"cypriot\"],\n    \"dominica\": [\"dominican\",\n                 \"dominican commonwealth\"],  # Not to be confused with \"dominican\" for the Dominican Republic.\n    \"eswatini\": [\"swazi\"],\n    \"fiji\": [\"fijian\"],\n    \"gambia\": [\"gambian\"],\n    \"ghana\": [\"ghanaian\"],\n    \"grenada\": [\"grenadian\"],\n    \"guyana\": [\"guyanese\"],\n    \"india\": [\"indian\"],\n    \"jamaica\": [\"jamaican\"],\n    \"kenya\": [\"kenyan\"],\n    \"kiribati\": [\"i-kiribati\"],\n    \"lesotho\": [\"mosotho\", \n                \"basotho\"],\n    \"malawi\": [\"malawian\"],\n    \"malaysia\": [\"malaysian\"],\n    \"maldives\": [\"maldivian\"],\n    \"malta\": [\"maltese\"],\n    \"mauritius\": [\"mauritian\"],\n    \"mozambique\": [\"mozambican\"],\n    \"namibia\": [\"namibian\"],\n    \"nauru\": [\"nauruan\"],\n    \"new zealand\": [\"new zealander\", \n                    \"kiwi\"],\n    \"nigeria\": [\"nigerian\"],\n    \"pakistan\": [\"pakistani\"],\n    \"papua new guinea\": [\"papuan\", \n                         \"guinean\"],\n    \"rwanda\": [\"rwandan\"],\n    \"saint lucia\": [\"saint lucian\"],\n    \"samoa\": [\"samoan\"],\n    \"seychelles\": [\"seychellois\"],\n    \"sierra leone\": [\"sierra leonean\"],\n    \"singapore\": [\"singaporean\"],\n    \"solomon islands\": [\"solomon islander\"],\n    \"south africa\": [\"south african\"],\n    \"sri lanka\": [\"sri lankan\"],\n    \"st kitts and nevis\": [\"kittitian\", \"nevisian\"],\n    \"st vincent and the grenadines\": [\"vincentian\"],\n    \"tanzania\": [\"tanzanian\"],\n    \"tonga\": [\"tongan\"],\n    \"trinidad and tobago\": [\"trinidadian\", \n                            \"tobagonian\"],\n    \"tuvalu\": [\"tuvaluan\"],\n    \"uganda\": [\"ugandan\"],\n    \"united kingdom\": [\"british\", \n                       \"english\", \n                       \"scottish\", \n                       \"welsh\", \n                       \"northern irish\"],\n    \"vanuatu\": [\"vanuatuan\"],\n    \"zambia\": [\"zambian\"],\n}\n\n\nChecking citizenship and allegiance to the sovereign with allegiance_test()\nWith this list, the first thing we will need to do is code a function that can check a defendant’s citizenship attribute against this dictionary to determine whether they owe the sovereign allegiance. Because a defendant’s citizenship is generally an attribute about them, and not about the facts or the offence (generally speaking), it makes sense to turn this into a Defendant attribute. But because the allegiance question so rarely comes up, future iterations of the Defendant class may move this function into an Offence function or just out into the world.\ndef allegiance_test(self):\n    \"\"\"\n    Determines whether a defendant owes allegiance to the sovereign based\n    on their citizenship. The method iterates over the list of citizenships\n    and checks each one. If the individual has \"dominican\" citizenship, \n    the program must further determine whether the individual is a citizen\n    of Dominica (Commonwealth) or the Dominican Republic (not Commonwealth).\n\n    For \"dominican\" citizenship, it invokes the _handle_dominican method to handle\n    the special case. For other citizenships, it checks if they are Commonwealth\n    using the _is_commonwealth_citizen method.\n\n    If a Commonwealth citizenship is found, it immediately returns True. If none \n    of the citizenships are Commonwealth, it returns False. If citizenship list is \n    empty or not provided, it also returns False.\n\n    Returns:\n        bool: True if the defendant has a Commonwealth citizenship, False otherwise.\n    \"\"\"\n\n    if self.citizenship:\n        for i, citizenship in enumerate(self.citizenship):\n            if citizenship.lower() == \"dominican\":\n                self.citizenship[i] = self._handle_dominican()\n                citizenship = self.citizenship[i]  # update citizenship value with new string\n\n            if self._is_commonwealth_citizen(citizenship):\n                return True\n        return False\n    else:\n        return False\n\n\nPrivate support functions _is_commonwealth_citizen() and _handle_dominican()\nTesting for a defendant’s allegiance contemplates two private methods: namely, the _handle_dominican methond and the _is_commonwealth_citizen method. _is_commonwealth_citizen() checks whether a given citizenship belongs to a Commonwealth country, while _handle_dominican() prompts the user for more input if a defendant has “dominican” citizenship. This is because a Dominican citizen may either be from the Dominican Republic, which is not a Commonwealth country, and Dominica, which is. These methods can be coded as follows:\n    def _is_commonwealth_citizen(self, citizenship):\n        \"\"\"\n        This is a private method that checks if a given citizenship belongs to a \n        Commonwealth country.\n\n        Args:\n            citizenship (str): The citizenship string to check. This should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if the citizenship is in the list of Commonwealth countries \n            or demonyms, False otherwise.\n\n        Note:\n            This method assumes that `COMMONWEALTH_DEMONYMS` is a dictionary \n            available in the global scope, where the keys are countries and \n            the values are lists of associated demonyms.\n        \"\"\"\n        \n        return any(citizenship.lower() in demonyms for demonyms in COMMONWEALTH_DEMONYMS.values())\n    \n    def _handle_dominican(self):\n        \"\"\"\n        This is a private method that checks if a \"dominican\" citizenship belongs \n        to the Commonwealth country Dominica or the non-Commonwealth country, \n        the Dominican Republic.\n\n        Args:\n            index (int): The index of \"dominican\" citizenship in the citizenship list.\n\n        Returns:\n            None\n        \"\"\"\n        \n        while True:\n            print(\"Are you from (1) Dominica or (2) the Dominican Republic?\")\n            response = input(\"Please enter 1 or 2: \").strip()\n            if response == \"1\":\n                return \"dominican commonwealth\"\n            elif response == \"2\":\n                return \"dominican not commonwealth\"\n            else:\n                print(\"Invalid input. Please enter 1 or 2.\")\nWith these methods in place, the next step is to access the citizenship attribute to see if a person owes allegiance to the sovereign.\n\n\n\nAircraft, spacecraft, the space station and the moon\nThe final step in settling jurisdiction is to deal with offences committed on aircraft, spacecraft, the ISS, the Lunar Gateway, or the lunar surface. Although the code developed here will be used for the high treason system, it has a much broader application and can be used for any future Criminal Code offences. This broad application notwithstanding, this jurisdictional section is unlikely to capture much criminal activity.\nConceptually, these different locales can be divided into two different groups:\n\nAircraft offences\nSpacecraft, the ISS, the Lunar Gateway, and the lunar surface\n\nThe main difference between these two groups is the Partner State consideration in the latter group.\n\nCC s 7(1) — Offences committed on aircraft\n\nNotwithstanding anything in this Act or any other Act, every one who\n\n     (a) on or in respect of an aircraft\n\n          (i) registered in Canada under regulations made under the Aeronautics Act, or\n          (ii) leased without crew and operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations,\n\n  while the aircraft is in flight, or\n\n      (b) on any aircraft, while the aircraft is in flight if the flight terminated in Canada,\n\ncommits an act or omission in or outside Canada that if committed in Canada would be an offence punishable by indictment shall be deemed to have committed that act or omission in Canada.\n\nI outline this section’s control flow as follows:\n\nThe defendant is deemed to have committed an offence in Canada if:\n\nThe defendant committed an offence on an aircraft in flight AND\nThe aircraft was registered in Canada under regulations made under the Aeronautics Act OR\nThe aircraft was leased without crew AND operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as the owner of an aircraft registered in Canada under those regulations OR\nThe flight terminated in Canada\n\n\nThis control flow can be codified as a method to the Facts class, adding constructive jurisdiction to a case’s facts if sufficient facts exist.\ndef verify_constructive_jurisdiction_aircraft(self):\n    \"\"\"\n    Verifies whether an offence committed on an aircraft falls under Canadian jurisdiction and updates the jurisdiction attribute accordingly.\n\n    This method asks the user a series of questions to determine if the offence, when committed on an aircraft, falls under the Canadian \n    statute. If it does, the jurisdiction is updated to include the specific location.\n\n    Note:\n        This method uses the `input` function and thus is intended for use in an interactive context.\n    \"\"\"\n\n    deemed_jurisdiction = []\n\n    offense_committed = verify_yes_no(\"Was the offense committed on an aircraft in flight? (yes/no): \")\n    aircraft_registered = aircraft_leased = qualified_operator = flight_terminated = False\n\n    if offense_committed:\n        flight_terminated = verify_yes_no(\"Did the flight terminate in Canada? (yes/no): \")\n        aircraft_registered = verify_yes_no(\"Is the aircraft\\n * Registered in Canada under regulations made under the Aeronautics Act? (yes/no): \")\n        aircraft_leased = verify_yes_no(\" * Leased without crew operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n    if aircraft_leased:\n        qualified_operator = verify_yes_no(\" * Operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n\n\n    if aircraft_registered:\n        deemed_jurisdiction.append(\"deemed jurisdiction (legally registered aircraft)\")\n    if aircraft_leased and qualified_operator:\n        deemed_jurisdiction.append(\"deemed jurisdiction (legally leased and operated aircraft)\")\n    if flight_terminated:\n        deemed_jurisdiction.append(\"deemed jurisdiction (flight terminated in Canada)\")\n\n    for item in deemed_jurisdiction:\n        if item not in self.jurisdiction:\n            self.jurisdiction.append(item)\n\n\n\nSpacecraft, the International Space Station, the Lunar Gateway, and the lunar surface\n\nCC s 7(2.3) — Space Station — Canadian crew members\n\nDespite anything in this Act or any other Act, a Canadian crew member who, during a space flight, commits an act or omission outside Canada that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission is committed\n\n       (a) on, or in relation to, a flight element of the Space Station; or\n       (b) on any means of transportation to or from the Space Station.\n\n\n\nCC s 7(2.31) — Space Station — crew members of Partner States\n\nDespite anything in this Act or any other Act, a crew member of a Partner State who commits an act or omission outside Canada during a space flight on, or in relation to, a flight element of the Space Station or on any means of transportation to and from the Space Station that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission\n\n       (a) threatens the life or security of a Canadian crew member; or\n       (b) is committed on or in relation to, or damages, a flight element provided by Canada.\n\n\n\nCC s 7(2.35) — Lunar Gateway — Canadian crew members\n\nDespite anything in this Act or any other Act, a Canadian crew member who, during a space flight, commits an act or omission outside Canada that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission is committed\n\n   (a) on, or in relation to, a flight element of the Lunar Gateway;\n\n   (b) on any means of transportation to or from the Lunar Gateway; or\n\n   (c) on the surface of the Moon.\n\n\n\nCC s 7(2.36) — Lunar Gateway — crew members of Partner States\n\nDespite anything in this Act or any other Act, a crew member of a Partner State who commits an act or omission outside Canada during a space flight on, or in relation to, a flight element of the Lunar Gateway, on any means of transportation to and from the Lunar Gateway or on the surface of the Moon that if committed in Canada would constitute an indictable offence is deemed to have committed that act or omission in Canada, if that act or omission\n\n   (a) threatens the life or security of a Canadian crew member; or\n\n   (b) is committed on or in relation to, or damages, a flight element provided by Canada.\n\nThe control flow for this section roughly follows the following:\n\nPartner State member or authorized agent?\n\nSpace station\n\nCommit an offence on the ISS that\n\nThreatens the life of a Canadian crew member\nThreatens the security of a Canadian crew member\nIs in relation to a flight element provided by Canada\nDamages a flight element provided by Canada\nDamages a flight element provided by Canada\n\nCommit an offence en route to or from the ISS that\n\nThreatens the life of a Canadian crew member\nThreatens the security of a Canadian crew member\nIs in relation to a flight element provided by Canada\nDamages a flight element provided by Canada\nDamages a flight element provided by Canada\n\n\nLunar Gateway\n\nCommit an offence on the Lunar Gateway that\n\nThreatens the life of a Canadian crew member\nThreatens the security of a Canadian crew member\nIs in relation to a flight element provided by Canada\nDamages a flight element provided by Canada\nDamages a flight element provided by Canada\n\nCommit an offence en route to or from the Lunar Gateway that\n\nThreatens the life of a Canadian crew member\nThreatens the security of a Canadian crew member\nIs in relation to a flight element provided by Canada\nDamages a flight element provided by Canada\nDamages a flight element provided by Canada\n\n\nLunar surface\n\nCommit an offence on the lunar surface that\n\nThreatens the life of a Canadian crew member\nThreatens the security of a Canadian crew member\nIs in relation to a flight element provided by Canada\nDamages a flight element provided by Canada\nDamages a flight element provided by Canada\n\n\n\n\n    def verify_constructive_jurisdiction_space(self):\n        # List of possible locations\n        locations = [\"on the iss\", \n                     \"en route to iss\", \n                     \"on the lunar gateway\", \n                     \"en route to/from Lunar Gateway\", \n                     \"on the lunar surface\"]\n\n        # Combine all offences into one list\n        all_offences = [\"threatend a canadian crew member's life\", \n                        \"threatend a canadian crew member's security\", \n                        \"damaged a canadian flight element\", \n                        \"offended in relation to a canadian flight element\",\n                        \"damaged a canadian flight element\"]\n\n        partner_state_member = self._verify_partner_state(defendant.agency)\n        \n        if partner_state_member:\n            for offence in all_offences:\n                print(f\"The defendant {offence} — (yes/no): \")\n                offence_committed = input().lower()\n                if offence_committed == 'yes':\n                    for location in locations:\n                        print(f\"Did the offence take place {location}? (yes/no): \")\n                        offence_location = input().lower()\n                        if offence_location == 'yes':\n                            self.jurisdiction.append(f\"deemed jurisdiction ({offence} {location})\")\nThe code above contemplates a private _verify_partner_state function that will need to be defined. To do so, we need to first understand what constitutes a Partner State:\n\n\nCC s 7(2.34) — definition: Partner States\n\nAgreement has the same meaning as in section 2 of the Civil International Space Station Agreement Implementation Act.\n…\nPartner State means a State, other than Canada, who contracted to enter into the Agreement and for which the Agreement has entered into force in accordance with article 25 of the Agreement.\n\nThe pertinent section of Civil International Space Station Agreement Implementation Act art 25 reads as follows:\n\n\nThis Agreement shall remain open for signature by the States listed in the Preamble of this Agreement.\n\n\nThe Preamble then outlines the fact that Partner States are\n\nAn Act to implement the Agreement among the Government of Canada, Governments of Member States of the European Space Agency, the Government of Japan, the Government of the Russian Federation, and the Government of the United States of America concerning Cooperation on the Civil International Space Station and to make related amendments to other Acts.\n\nGiven the above information, a partner state is:\n\nCanada\nJapan;\nThe Russian Federation;\nThe United States of America; or\nA member state of the ESA\n\nESA member states include:\n\nAustria\nBelgium\nCzech Republic\nDenmark\nEstonia\nFinland\nFrance\nGermany\nGreece\nHungary\nIreland\nItaly\nLuxembourg\nNetherlands\nNorway\nPoland\nPortugal\nRomania\nSpain\nSweden\nSwitzerland\nUnited Kingdom\n\nThese can be expressed as Python dictionaries much in the same way that we dealt with Commonwealth countries above. A new agency attribute can be used to determine whether a person is a member of a partner state.\nPartner State membership does not seem to be tied to citizenship. Rather, a person is statutorily a member of a Partner State if they are a crew member of a Partner State. To the extent that it is possible for a person to be a crew member acting for a Partner State and not a citizen of that country, the two should be kept conceptually distinct from one another. Should the agency attribute prove to be useful for other Criminal Code provisions, the output here can be modified to specifically tie it to CC s 7(2.34).\nNON_ESA_PARTNER_STATE_DEMONYMS = {\n    \"canada\": (\"canadian\",),\n    \"japan\": (\"japanese\",),\n    \"russian federation\": (\"russian\",),\n    \"united states of america\": (\"american\",)\n}\n\nESA_PARTNER_STATE_DEMONYMS = {\n    \"austria\": (\"austrian\",),\n    \"belgium\": (\"belgian\",),\n    \"czech republic\": (\"czech\", \"czechoslovakian\"),\n    \"denmark\": (\"danish\",),\n    \"estonia\": (\"estonian\",),\n    \"finland\": (\"finnish\",),\n    \"france\": (\"french\",),\n    \"germany\": (\"german\",),\n    \"greece\": (\"greek\",),\n    \"hungary\": (\"hungarian\",),\n    \"ireland\": (\"irish\",),\n    \"italy\": (\"italian\",),\n    \"luxembourg\": (\"luxembourger\",),\n    \"netherlands\": (\"dutch\",),\n    \"norway\": (\"norwegian\",),\n    \"poland\": (\"polish\",),\n    \"portugal\": (\"portuguese\",),\n    \"romania\": (\"romanian\",),\n    \"spain\": (\"spanish\",),\n    \"sweden\": (\"swedish\",),\n    \"switzerland\": (\"swiss\",),\n    \"united kingdom\": (\"british\", \"scottish\", \"english\", \"welsh\", \"irish\")\n}\nOnce the Partner States are archived in the dictionary, we can create a private method that will determine whether a particular defendant’s agency variable correlates to a Partner State value.\n    def _verify_partner_state(self, memberships):\n        \"\"\"\n        This is a private method that checks if any given citizenship belongs to a \n        Partner State country.\n\n        Args:\n            citizenships (list): The list of citizenships to check. Each should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if any of the citizenships is in the list of Partner States' countries \n            or demonyms, False otherwise.\n        \"\"\"\n\n        # Convert the dictionary values (which are tuples) into sets for easy searching\n        non_esa_demonyms = set(val for sublist in NON_ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n        esa_demonyms = set(val for sublist in ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n\n        for membership in memberships:\n            if membership in non_esa_demonyms or membership in esa_demonyms:\n                return True\n\n        return False"
  },
  {
    "objectID": "notebooks/bses_2.html#jurisdiction-verification-through-verify_high_treason",
    "href": "notebooks/bses_2.html#jurisdiction-verification-through-verify_high_treason",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Jurisdiction verification through verify_high_treason()",
    "text": "Jurisdiction verification through verify_high_treason()\nThe final step is to code a function that will check to determine whether there is jurisdiction for an offence. To do so, the function will need to check both Facts and Defendant objects to see whether any of the necessary jurisdictional preconditions have been met. Because this offence has its own form of constructive jurisdiction, the control flow will have to account for that:\n\nIs the offence committed in Canada?\n\nIs the defendant jurisdictionally exempt?\nCan jurisdiction be constructed?\n\nAircraft jurisdiction\nSpace jurisdiction\n\nIs the offence treason?\n\nDoes the defendant owe allegiance to Canada?\n\n\n\nThe verify_high_treason function determines whether the offence is made out. The previous verify_high_treason function simply checked to see if matches had any content. If it did, it would print them out. But jurisdiction introduces a new issue, such that we can’t say that high treason was committed unless we also establish that the offence occurred in Canada. To do this, we need to expand verify_high_treason’s scope. For now, this function is class-independent.\ndef verify_high_treason(matches, facts, defendant):\n    \"\"\"\n    Determines whether the factual and legal matrix is sufficient to make out \n    high treason.\n    \"\"\"\n    \n    reasons = []\n\n    if not matches:\n        reasons.append(\"* No wrongful act\")\n\n    # Check allegiance\n    if not defendant.allegiance_test():\n        reasons.append(\"* Defendant does not owe allegiance to the sovereign\")\n\n    # If defendant doesn't owe allegiance, then we also check for jurisdiction\n    if not defendant.allegiance_test() and facts.jurisdiction == \"not recognized\":\n        reasons.append(\"* No jurisdiction\")\n\n    # If there are any reasons in the list, print them out. \n    # Otherwise, high treason has been committed.\n    if reasons:\n        print(\"High treason not committed:\")\n        for reason in reasons:\n            print(reason)\n    else:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)"
  },
  {
    "objectID": "notebooks/bses_2.html#constants",
    "href": "notebooks/bses_2.html#constants",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Constants",
    "text": "Constants\n\nCANADIAN_PROVINCES: dict[str, tuple[str, str]] = {\n    'Alberta': ('AB', 'Alta'),\n    'British Columbia': ('BC', 'B.C.'),\n    'Manitoba': ('MB', 'Man.'),\n    'New Brunswick': ('NB', 'N.B.'),\n    'Newfoundland and Labrador': ('NL', 'N.L.'),\n    'Nova Scotia': ('NS', 'N.S.'),\n    'Ontario': ('ON', 'Ont.'),\n    'Prince Edward Island': ('PE', 'P.E.I.'),\n    'Quebec': ('QC', 'Que.'),\n    'Saskatchewan': ('SK', 'Sask.')\n}\n\nCANADIAN_TERRITORIES: dict[str, tuple[str, str]] = {\n    'Northwest Territories': ('NT', 'N.W.T.'),\n    'Nunavut': ('NU', 'Nvt.'),\n    'Yukon': ('YT', 'Y.T.')\n}\n\nPUBLIC_EMPLOYEE_CRITERIA = (\"Is the defendant a public service employee?\",\n                            \"Does the Public Service Commission have authority to appoint the defendant?\",\n                            \"Does any other federal statute confer authority to appoint the defendant?\")\n\nOTHER_ACTS_OF_PARLIAMENT = {\n    \n}\n\nCOMMONWEALTH_DEMONYMS = {\n    \"antigua and barbuda\": [\"antiguan\", \n                            \"barbudan\"],\n    \"australia\": [\"australian\"],\n    \"the bahamas\": [\"bahamian\"],\n    \"bangladesh\": [\"bangladeshi\"],\n    \"barbados\": [\"barbadian\", \n                 \"bajan\"],\n    \"belize\": [\"belizean\"],\n    \"botswana\": [\"botswanan\"],\n    \"brunei darussalam\": [\"bruneian\"],\n    \"cameroon\": [\"cameroonian\"],\n    \"canada\": [\"canadian\"],\n    \"cyprus\": [\"cypriot\"],\n    \"dominica\": [\"dominican\",\n                 \"dominican commonwealth\"],\n    \"eswatini\": [\"swazi\"],\n    \"fiji\": [\"fijian\"],\n    \"gambia\": [\"gambian\"],\n    \"ghana\": [\"ghanaian\"],\n    \"grenada\": [\"grenadian\"],\n    \"guyana\": [\"guyanese\"],\n    \"india\": [\"indian\"],\n    \"jamaica\": [\"jamaican\"],\n    \"kenya\": [\"kenyan\"],\n    \"kiribati\": [\"i-kiribati\"],\n    \"lesotho\": [\"mosotho\", \n                \"basotho\"],\n    \"malawi\": [\"malawian\"],\n    \"malaysia\": [\"malaysian\"],\n    \"maldives\": [\"maldivian\"],\n    \"malta\": [\"maltese\"],\n    \"mauritius\": [\"mauritian\"],\n    \"mozambique\": [\"mozambican\"],\n    \"namibia\": [\"namibian\"],\n    \"nauru\": [\"nauruan\"],\n    \"new zealand\": [\"new zealander\", \n                    \"kiwi\"],\n    \"nigeria\": [\"nigerian\"],\n    \"pakistan\": [\"pakistani\"],\n    \"papua new guinea\": [\"papuan\", \n                         \"guinean\"],\n    \"rwanda\": [\"rwandan\"],\n    \"saint lucia\": [\"saint lucian\"],\n    \"samoa\": [\"samoan\"],\n    \"seychelles\": [\"seychellois\"],\n    \"sierra leone\": [\"sierra leonean\"],\n    \"singapore\": [\"singaporean\"],\n    \"solomon islands\": [\"solomon islander\"],\n    \"south africa\": [\"south african\"],\n    \"sri lanka\": [\"sri lankan\"],\n    \"st kitts and nevis\": [\"kittitian\", \"nevisian\"],\n    \"st vincent and the grenadines\": [\"vincentian\"],\n    \"tanzania\": [\"tanzanian\"],\n    \"tonga\": [\"tongan\"],\n    \"trinidad and tobago\": [\"trinidadian\", \n                            \"tobagonian\"],\n    \"tuvalu\": [\"tuvaluan\"],\n    \"uganda\": [\"ugandan\"],\n    \"united kingdom\": [\"british\", \n                       \"english\", \n                       \"scottish\", \n                       \"welsh\", \n                       \"northern irish\"],\n    \"vanuatu\": [\"vanuatuan\"],\n    \"zambia\": [\"zambian\"],\n}\n\nNON_ESA_PARTNER_STATE_DEMONYMS = {\n    \"canada\": (\"canadian\",),\n    \"japan\": (\"japanese\",),\n    \"russian federation\": (\"russian\",),\n    \"united states of america\": (\"american\",)\n}\n\nESA_PARTNER_STATE_DEMONYMS = {\n    \"austria\": (\"austrian\",),\n    \"belgium\": (\"belgian\",),\n    \"czech republic\": (\"czech\", \"czechoslovakian\"),\n    \"denmark\": (\"danish\",),\n    \"estonia\": (\"estonian\",),\n    \"finland\": (\"finnish\",),\n    \"france\": (\"french\",),\n    \"germany\": (\"german\",),\n    \"greece\": (\"greek\",),\n    \"hungary\": (\"hungarian\",),\n    \"ireland\": (\"irish\",),\n    \"italy\": (\"italian\",),\n    \"luxembourg\": (\"luxembourger\",),\n    \"netherlands\": (\"dutch\",),\n    \"norway\": (\"norwegian\",),\n    \"poland\": (\"polish\",),\n    \"portugal\": (\"portuguese\",),\n    \"romania\": (\"romanian\",),\n    \"spain\": (\"spanish\",),\n    \"sweden\": (\"swedish\",),\n    \"switzerland\": (\"swiss\",),\n    \"united kingdom\": (\"british\", \"scottish\", \"english\", \"welsh\", \"irish\")\n}"
  },
  {
    "objectID": "notebooks/bses_2.html#utility-functions",
    "href": "notebooks/bses_2.html#utility-functions",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Utility functions",
    "text": "Utility functions\n\ndef verify_yes_no(prompt):\n    \"\"\"\n    Prompts user for a yes/no response and validates input.\n\n    Args:\n        prompt (str): The prompt to display to the user.\n\n    Returns:\n        bool: True for 'yes', False for 'no'.\n    \"\"\"\n    while True:\n        response = input(prompt).strip().lower()\n        if response in ['yes', 'no']:\n            return response == 'yes'\n        else:\n            print(\"Invalid input. Please enter 'yes' or 'no'.\")"
  },
  {
    "objectID": "notebooks/bses_2.html#models",
    "href": "notebooks/bses_2.html#models",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Models",
    "text": "Models\n\nFacts\n\nfrom typing import Optional\n\nclass Facts:\n    \"\"\"\n    A basic class capable of handling the minimum facts required for a high \n    treason offence.\n\n    Attributes:\n        victim_category (str): The name of the victim of the offence.\n        offence_date (str): The date of the offence.\n        jurisdiction (str): The jurisdiction in which the offence took place.\n        actions (list): A list of actions that the defendant took against the \n            victim.\n        role (list): A list of roles that the defendant played in the offence.\n\n    A Facts object should account for one offence and offender. Any potential\n    path to a conviction should be represented by a distinct Facts object. \n    Multiple offences or offenders should be represented by multiple Facts \n    objects.\n    \"\"\"\n\n    def __init__(self, \n                 victim_category: str = None, \n                 offence_date: str = None, \n                 jurisdiction: str = None, \n                 actions: list = None, \n                 role: list = None,\n                 defendant: 'Defendant' = None\n                ):\n        self.victim_category = victim_category\n        self.offence_date = offence_date\n        self.jurisdiction = jurisdiction if jurisdiction is not None else []\n        self.actions = actions if actions is not None else []\n        self.role = role if role is not None else []\n        self.defendant = defendant\n\n        \n    def create_facts(self):\n        \"\"\"\n        Interactively collects details about the offence and stores them as \n        instance attributes.\n\n        This method asks the user for details about the victim, offence date, \n        jurisdiction, and actions related to the offence. \n        These details are then stored as instance attributes for future use.\n        \n        Note:\n            This method uses the `input` function and thus is intended for use \n            in an interactive context.\n        \"\"\"\n        \n        print(\"Please enter the facts of the case:\")\n\n        victim_category = input(\"Who is the victim? \")\n        victim_category = standardize_sovereign_names(victim_category)\n        victim_category = standardize_canada_names(victim_category)\n        complainant = Complainant(victim_category)\n        offence_date = input(\"Date of the offence (YYYY-MM-DD): \")\n        jurisdiction = input(\"Jurisdiction: \")\n        actions = high_treason_facts(victim_category)\n\n        self.victim_category = complainant.name\n        self.offence_date = offence_date\n        self.actions = actions\n        self.jurisdiction = jurisdiction\n\n        \n    def verify_jurisdiction(self):\n        \"\"\"\n        Runs a broad analysis to determine whether Canadian jurisdiction exists\n        or can be construed through the circumstances.\n        \"\"\"\n        \n        if self.verify_canadian_jurisdiction(self.jurisdiction):\n            self.jurisdiction = jurisdiction\n        elif self.verify_constructive_jurisdiction_aircraft():\n            self.jurisdiction = jurisdiction\n        elif self.verify_constructive_jurisdiction_space():\n            self.jurisdiction = jurisdiction\n        else:\n            return False\n\n            \n    def verify_canadian_jurisdiction(self,\n                                     jurisdiction: list, \n                                     provinces: dict[str, tuple[str, str]] = CANADIAN_PROVINCES, \n                                     territories: dict[str, tuple[str, str]] = CANADIAN_TERRITORIES) -&gt; tuple[bool, Optional[str]]:\n        \"\"\"\n        This function checks if a given jurisdiction is recognized as part of Canada.\n\n        The function accepts a string representing a jurisdiction and two \n        optional dictionaries representing provinces and territories. Each \n        dictionary maps a region's name to a tuple consisting of its \n        abbreviation and French translation. The function checks if the \n        jurisdiction matches the name, abbreviation, or French translation of \n        any of the provinces or territories. The function also checks if the \n        jurisdiction is \"canada\" or its abbreviation \"ca\".\n\n        If a match is found, the function returns True; otherwise, it returns \n        False.\n\n        Args:\n            jurisdiction (str): The jurisdiction to check.\n            provinces (dict[str, tuple[str, str]], optional): A dictionary of \n            Canadian provinces. Defaults to CANADIAN_PROVINCES.\n            territories (dict[str, tuple[str, str]], optional): A dictionary of\n            Canadian territories. Defaults to CANADIAN_TERRITORIES.\n\n        Returns:\n            tuple[bool, Optional[str]]: A tuple where the first element is a \n            boolean indicating if the jurisdiction is recognized, and the \n            second element is an optional string message.\n        \"\"\"\n        \n        for item in jurisdiction:\n            if item.lower() in ('canada', 'ca'):\n                return True\n\n            for region in [provinces, territories]:\n                for key, value in region.items():\n                    if item.lower() in [key.lower(), value[0].lower(), value[1].lower()]:\n                        return True\n            return False\n\n    \n    def verify_constructive_jurisdiction_aircraft(self):\n        \"\"\"\n        Verifies whether an offence committed on an aircraft falls under \n        Canadian jurisdiction and updates the jurisdiction attribute \n        accordingly.\n\n        This method asks the user a series of questions to determine if the \n        offence, when committed on an aircraft, falls under the Canadian \n        statute. If it does, the jurisdiction is updated to include the \n        specific location.\n\n        Note:\n            This method uses the `input` function and thus is intended for use \n            in an interactive context.\n        \"\"\"\n        \n        deemed_jurisdiction = []\n\n        offense_committed = verify_yes_no(\"Was the offense committed on an aircraft in flight? (yes/no): \")\n        aircraft_registered = aircraft_leased = qualified_operator = flight_terminated = False\n\n        if offense_committed:\n            flight_terminated = verify_yes_no(\"Did the flight terminate in Canada? (yes/no): \")\n            aircraft_registered = verify_yes_no(\"Is the aircraft\\n * Registered in Canada under regulations made under the Aeronautics Act? (yes/no): \")\n            aircraft_leased = verify_yes_no(\" * Leased without crew operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n        if aircraft_leased:\n            qualified_operator = verify_yes_no(\" * Operated by a person who is qualified under regulations made under the Aeronautics Act to be registered as owner of an aircraft registered in Canada under those regulations? (yes/no): \")\n            \n\n        if aircraft_registered:\n            deemed_jurisdiction.append(\"deemed jurisdiction (legally registered aircraft)\")\n        if aircraft_leased and qualified_operator:\n            deemed_jurisdiction.append(\"deemed jurisdiction (legally leased and operated aircraft)\")\n        if flight_terminated:\n            deemed_jurisdiction.append(\"deemed jurisdiction (flight terminated in Canada)\")\n\n        for item in deemed_jurisdiction:\n            if item not in self.jurisdiction:\n                self.jurisdiction.append(item)\n \n\n    def verify_constructive_jurisdiction_space(self):\n        # List of possible locations\n        locations = [\"on the iss\", \n                     \"en route to iss\", \n                     \"on the lunar gateway\", \n                     \"en route to/from Lunar Gateway\", \n                     \"on the lunar surface\"]\n\n        # Combine all offences into one list\n        all_offences = [\"threatend a canadian crew member's life\", \n                        \"threatend a canadian crew member's security\", \n                        \"damaged a canadian flight element\", \n                        \"offended in relation to a canadian flight element\",\n                        \"damaged a canadian flight element\"]\n\n        partner_state_member = self._verify_partner_state(self.defendant.agency)\n        \n        if partner_state_member:\n            for offence in all_offences:\n                print(f\"The defendant {offence} — (yes/no): \")\n                offence_committed = input().lower()\n                if offence_committed == 'yes':\n                    for location in locations:\n                        print(f\"Did the offence take place {location}? (yes/no): \")\n                        offence_location = input().lower()\n                        if offence_location == 'yes':\n                            self.jurisdiction.append(f\"deemed jurisdiction ({offence} {location})\")\n\n\n    def _verify_partner_state(self, memberships):\n        \"\"\"\n        This is a private method that checks if any given citizenship belongs to a \n        Partner State country.\n\n        Args:\n            citizenships (list): The list of citizenships to check. Each should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if any of the citizenships is in the list of Partner States' countries \n            or demonyms, False otherwise.\n        \"\"\"\n\n        # Convert the dictionary values (which are tuples) into sets for easy searching\n        non_esa_demonyms = set(val for sublist in NON_ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n        esa_demonyms = set(val for sublist in ESA_PARTNER_STATE_DEMONYMS.values() for val in sublist)\n\n        for membership in memberships:\n            if membership in non_esa_demonyms or membership in esa_demonyms:\n                return True\n\n        return False"
  },
  {
    "objectID": "notebooks/bses_2.html#defendant",
    "href": "notebooks/bses_2.html#defendant",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Defendant",
    "text": "Defendant\n\nclass Defendant:\n    \"\"\"\n    Creates a defendant instance. Necessary to the extent that some offences \n    only apply to defendants with certain characteristics, and to the extent\n    that some offences will involve multiple defendants who need to be kept\n    distinct from one another.\n    \"\"\"\n    \n    def __init__(self, \n                 name=None, \n                 age=None, \n                 liability=None, \n                 criminal_record=None,\n                 vocation=None,\n                 citizenship=None,\n                 agency=None):\n        \n        self.name = name\n        self.age = age\n        self.liability = liability\n        self.criminal_record = criminal_record\n        self.vocation = vocation if vocation is not None else []\n        self.citizenship = citizenship if citizenship is not None else []\n        self.agency = agency if agency is not None else []\n\n    def public_employee_test(self):\n        \"\"\"\n        Verifies whether a defendant is a public employee as understood by the \n        Criminal Code.\n        \"\"\"\n        \n        for question in PUBLIC_EMPLOYEE_CRITERIA:\n            response = input(question + \" (yes/no): \")\n            if response.strip().lower() != 'yes':\n                return\n        self.vocation.append(\"public employee\")\n\n    def allegiance_test(self):\n        \"\"\"\n        Determines whether a defendant owes allegiance to the sovereign based\n        on their citizenship. The method iterates over the list of citizenships\n        and checks each one. If the individual has \"dominican\" citizenship, \n        the program must further determine whether the individual is a citizen\n        of Dominica (Commonwealth) or the Dominican Republic (not Commonwealth).\n\n        For \"dominican\" citizenship, it invokes the _handle_dominican method to handle\n        the special case. For other citizenships, it checks if they are Commonwealth\n        using the _is_commonwealth_citizen method.\n\n        If a Commonwealth citizenship is found, it immediately returns True. If none \n        of the citizenships are Commonwealth, it returns False. If citizenship list is \n        empty or not provided, it also returns False.\n\n        Returns:\n            bool: True if the defendant has a Commonwealth citizenship, False otherwise.\n        \"\"\"\n        \n        if self.citizenship:\n            for i, citizenship in enumerate(self.citizenship):\n                if citizenship.lower() == \"dominican\":\n                    self.citizenship[i] = self._handle_dominican()\n                    citizenship = self.citizenship[i]  # update citizenship value with new string\n\n                if self._is_commonwealth_citizen(citizenship):\n                    return True\n            return False\n        else:\n            return False\n\n    def _is_commonwealth_citizen(self, citizenship):\n        \"\"\"\n        This is a private method that checks if a given citizenship belongs to a \n        Commonwealth country.\n\n        Args:\n            citizenship (str): The citizenship string to check. This should be a \n            lowercase string that denotes a country or its demonym.\n\n        Returns:\n            bool: True if the citizenship is in the list of Commonwealth countries \n            or demonyms, False otherwise.\n\n        Note:\n            This method assumes that `COMMONWEALTH_DEMONYMS` is a dictionary \n            available in the global scope, where the keys are countries and \n            the values are lists of associated demonyms.\n        \"\"\"\n        \n        return any(citizenship.lower() in demonyms for demonyms in COMMONWEALTH_DEMONYMS.values())\n\n    def _handle_dominican(self):\n        \"\"\"\n        This is a private method that checks if a \"dominican\" citizenship belongs \n        to the Commonwealth country Dominica or the non-Commonwealth country, \n        the Dominican Republic.\n\n        Args:\n            index (int): The index of \"dominican\" citizenship in the citizenship list.\n\n        Returns:\n            None\n        \"\"\"\n        \n        while True:\n            print(\"Are you from (1) Dominica or (2) the Dominican Republic?\")\n            response = input(\"Please enter 1 or 2: \").strip()\n            if response == \"1\":\n                return \"dominican commonwealth\"\n            elif response == \"2\":\n                return \"dominican not commonwealth\"\n            else:\n                print(\"Invalid input. Please enter 1 or 2.\")"
  },
  {
    "objectID": "notebooks/bses_2.html#updated-main.py-functions",
    "href": "notebooks/bses_2.html#updated-main.py-functions",
    "title": "Basic statutory expert system 2 — jurisdiction",
    "section": "Updated main.py functions",
    "text": "Updated main.py functions\n\ndef verify_high_treason(matches, facts, defendant):\n    \"\"\"\n    Determines whether the factual and legal matrix is sufficient to make out \n    high treason.\n    \"\"\"\n    \n    reasons = []\n\n    if not matches:\n        reasons.append(\"* No wrongful act\")\n\n    # Check allegiance\n    if not defendant.allegiance_test():\n        reasons.append(\"* Defendant does not owe allegiance to the sovereign\")\n\n    # If defendant doesn't owe allegiance, then we also check for jurisdiction\n    if not defendant.allegiance_test() and facts.jurisdiction == \"not recognized\":\n        reasons.append(\"* No jurisdiction\")\n\n    # If there are any reasons in the list, print them out. \n    # Otherwise, high treason has been committed.\n    if reasons:\n        print(\"High treason not committed:\")\n        for reason in reasons:\n            print(reason)\n    else:\n        print(\"High treason committed. Matches:\")\n        for match in matches:\n            print(match)"
  },
  {
    "objectID": "notebooks/bses_3.html",
    "href": "notebooks/bses_3.html",
    "title": "Basic statutory expert system 3 — punishment",
    "section": "",
    "text": "Punishment for high treason\n47 (1) Every one who commits high treason is guilty of an indictable offence and shall be sentenced to imprisonment for life.\n745 Subject to section 745.1, the sentence to be pronounced against a person who is to be sentenced to imprisonment for life shall be\n\nin respect of a person who has been convicted of high treason or first degree murder, that the person be sentenced to imprisonment for life without eligibility for parole until the person has served twenty-five years of the sentence;"
  },
  {
    "objectID": "posts/bses-2-jurisdiction/index.html#conclusion",
    "href": "posts/bses-2-jurisdiction/index.html#conclusion",
    "title": "BSES part 2: adding jurisdictional functionality",
    "section": "",
    "text": "The basic statutory expert system now accounts for jurisdiction and high treason’s offence elements. The next step will be to create functions that allow the program to deal with case law, interpretive ambiguities, and legal uncertainties.\nIn the first post, I cited high treason’s limited case law base as a reason for building an expert system around it. Because case law introduces new legal rules, nuances, definitions, and applications, accounting for case law necessarily complicates statutory interpretation control flow. Bypassing these complications for a minimally-viable product is a sensible way to start. But once we have that MVP, we need a system that accounts for legal ambiguities and tells the user when more than one conclusion is possible. Because high treason has limited court consideration, these potential complications will be much fewer than those introduced in frequently-charged offences.\n[^1] As the system develops, jurisdiction may become a more significant issue. If that proves to be the case, jurisdictional functions will likely have to move to a separate class. For now, treating them as just another fact makes sense. [^2] See note 1 above. The same logic applies to stray functions that deal with individual offences. How these are best dealt with is still very much to be determined."
  }
]